<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL划题复习</title>
    <url>/post/4366.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL划题复习整理"><a href="#MySQL划题复习整理" class="headerlink" title="MySQL划题复习整理"></a>MySQL划题复习整理</h1><a id="more"></a>

<h2 id="什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级构造的优点是什么？-P46"><a href="#什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级构造的优点是什么？-P46" class="headerlink" title="什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级构造的优点是什么？(P46)"></a>什么是外部模式？概念模式？内部模式？它们之间有何联系？这种分级构造的优点是什么？(P46)</h2><ul>
<li><p>外部模式又称子模式，介于模式与应用之间，是用户与数据库之间的接口，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
</li>
<li><p>概念模式简称模式，是由数据库设计者综合所有用户数据，按照统一的观点构造的对数据库全局逻辑结构的描述。</p>
</li>
<li><p>内部模式也称存储模式，是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
</li>
<li><p>一个数据库结构从逻辑上可以划分为三个层次：外部模式（External&#8194;Schema），概念模式（Conceptual&#8194;Schema）和内部模式（Internal&#8194;Schema），称为数据库系统的三级模式结构。</p>
</li>
<li><p>数据库系统的三级模式是对数据进行三个级别的抽象。它把数据的具体组织留给DBMS去做，用户只要抽象地处理数据，而不必关心数据在机器中的具体表示方式和存储方式。数据库的三级结构是依靠映像来联系和互相转换的。正是这两层映像保证了数据库系统中的数据具有较高的数据独立性。</p>
</li>
</ul>
<h2 id="在数据库技术中，为提高数据库的逻辑独立性和物理独立性，数据库的结构被划分成用户级、-和储存级三个层次。-P48"><a href="#在数据库技术中，为提高数据库的逻辑独立性和物理独立性，数据库的结构被划分成用户级、-和储存级三个层次。-P48" class="headerlink" title="在数据库技术中，为提高数据库的逻辑独立性和物理独立性，数据库的结构被划分成用户级、( )和储存级三个层次。(P48)"></a>在数据库技术中，为提高数据库的逻辑独立性和物理独立性，数据库的结构被划分成用户级、( )和储存级三个层次。(P48)</h2><h2 id="A-管理员级-B-外部级-C-概念级-D-内部级"><a href="#A-管理员级-B-外部级-C-概念级-D-内部级" class="headerlink" title="A. 管理员级  B. 外部级  C. 概念级  D. 内部级"></a>A. 管理员级  B. 外部级  C. 概念级  D. 内部级</h2><p>答案：C</p>
<h2 id="在数据库的三级模式结构中，描述数据库中全体数据的逻辑结构和特征的是（）。"><a href="#在数据库的三级模式结构中，描述数据库中全体数据的逻辑结构和特征的是（）。" class="headerlink" title="在数据库的三级模式结构中，描述数据库中全体数据的逻辑结构和特征的是（）。"></a>在数据库的三级模式结构中，描述数据库中全体数据的逻辑结构和特征的是（）。</h2><h2 id="A-外模式-B-内模式-C-存储模式-D-模式"><a href="#A-外模式-B-内模式-C-存储模式-D-模式" class="headerlink" title="A. 外模式  B. 内模式  C. 存储模式  D. 模式"></a>A. 外模式  B. 内模式  C. 存储模式  D. 模式</h2><p>答案：D</p>
<hr>
<h2 id="广义笛卡尔积运算"><a href="#广义笛卡尔积运算" class="headerlink" title="广义笛卡尔积运算"></a>广义笛卡尔积运算</h2><p>R∪S：将关系相同的数据合并，并记录下来，并且记录下来的数据都是完全不同的。</p>
<p>R∩S：得到的是关系相同的记录。</p>
<p>R-S：在关系R中去掉和关系S中相同的记录。</p>
<p>RxS：关系R的每条记录后面都跟上关系S的全部记录。</p>
<h3 id="关系和关系模式的关系"><a href="#关系和关系模式的关系" class="headerlink" title="关系和关系模式的关系"></a>关系和关系模式的关系</h3><h3 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h3><p><code>D1 × D2 × ··· × Dn 的子集叫做在域D1，D2，···，Dn 上的关系，表示为 R(D1，D2，···，Dn )，其中R就是关系名，n就是目或度。 一个关系对应一张二维表，二维表就是关系名。</code></p>
<p>例如：</p>
<hr>
<p>​                    姓名                                            性别                                            小说名</p>
<hr>
<p>​                    唐僧                                            男                                                西游记</p>
<p>​                    宋江                                            男                                                水浒传</p>
<p>​                    林黛玉                                        女                                                红楼梦</p>
<hr>
<h3 id="关系模式："><a href="#关系模式：" class="headerlink" title="关系模式："></a>关系模式：</h3><p><code>在二维表中的行定义，即对关系的描述称为关系模式。</code></p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>1.关系是关系模式在某一时刻的状态或内容。 </p>
<p>2.关系模式是静态的；关系是动态的。</p>
<p>3.关系模式是二维表的表头属性等，即一个二维表的主要架构。由于二维表的属性名一般不会修改，所以呈现出静态。</p>
<p>4.关系是一张二维表的具体数据，除去表头外各数据间的联系。由于二维表中是数据会时常修改，所以呈现出动态。</p>
<hr>
<h2 id="数据库特点"><a href="#数据库特点" class="headerlink" title="数据库特点"></a>数据库特点</h2><ul>
<li><p>数据结构化</p>
</li>
<li><p>实现数据共享</p>
</li>
<li><p>数据独立性高</p>
</li>
<li><p>数据统一管理与控制</p>
</li>
<li><p>减少数据的冗余度</p>
</li>
<li><p>数据一致性和可维护性</p>
</li>
<li><p>故障恢复</p>
</li>
</ul>
<hr>
<h2 id="数据库不一致的原因"><a href="#数据库不一致的原因" class="headerlink" title="数据库不一致的原因"></a>数据库不一致的原因</h2><ul>
<li><p>由于数据冗余造成的</p>
</li>
<li><p>由于并发控制不当造成的</p>
</li>
<li><p>由于各种故障、错误造成的。</p>
</li>
</ul>
<hr>
<h2 id="关系代数运算特点"><a href="#关系代数运算特点" class="headerlink" title="关系代数运算特点"></a>关系代数运算特点</h2><p>运算对象和结果都是关系</p>
<hr>
<h2 id="SQL语言特点"><a href="#SQL语言特点" class="headerlink" title="SQL语言特点"></a>SQL语言特点</h2><ul>
<li><p>1.高度非过程化</p>
</li>
<li><p>2.功能完备并且一体化</p>
</li>
<li><p>3.统一的语法结构</p>
</li>
<li><p>4.语言简洁，易学易用（P79）</p>
</li>
<li><p>5.能为编程提供多种API(老师出题时的答案)</p>
<p>6.面向集合的操作方式</p>
<p>7.对于数据统计方便直观（网上补充）</p>
</li>
</ul>
<hr>
<h2 id="表中插入数据"><a href="#表中插入数据" class="headerlink" title="表中插入数据"></a>表中插入数据</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into table_name (column1, column2, column3, ...)</span><br><span class="line">values (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into table_name</span><br><span class="line">values (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure>

<p>方法一没有指定要插入数据的名称，只提供要插入的值，即可添加一行新的数据。</p>
<p>方法二要为表中的所有列添加值，不需要在SQL查询中指定列名称。但是，请确保值的顺序与表中的列顺序相同。</p>
<hr>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user XXX;		&#x2F;&#x2F;删除已存在的用户</span><br><span class="line">delete from user where user&#x3D;&#39;XXX&#39; and host&#x3D;&#39;localhost&#39;; &#x2F;&#x2F;删除用户</span><br><span class="line">flush privileges; &#x2F;&#x2F;刷新权限；否则下次使用create语句创建用户时会报错</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关系规范化操作异常原因"><a href="#关系规范化操作异常原因" class="headerlink" title="关系规范化操作异常原因"></a>关系规范化操作异常原因</h2><ul>
<li><p>数据冗余大</p>
</li>
<li><p>插入异常</p>
</li>
<li><p>删除异常</p>
</li>
<li><p>更新异常</p>
</li>
</ul>
<hr>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式实际上表示关系模式满足的某种约束级别。当关系模式满足某级别范式要求的约束条件时，就称这个关系模式属于这个级别的范式，记作R∈xNF。</p>
<p>联系： 5NF⊂4NF⊂BCNF⊂3NF⊂2NF⊂1NF</p>
<hr>
<p>第一范式：设R是一个关系模式，如果R中的每一个属性A的属性名和属性值都是不可再分的，则称R属于第一范式，记作R∈1NF。</p>
<p>第二范式：若R∈1NF，且每一个非主属性都完全函数依赖于码，则R∈2NF。</p>
<p>第三范式：关系模式R(U,F)中若不存在这样的码X，属性组Y及非主属性组Z(Z⫋Y)，使得X→Y,Y(→/)X,Y→Z成立，则称R(U,F)∈3NF</p>
<p>BCNF：关系模式R(U,F)∈1NF，若每一个决定因素都含有码，则R∈BCNF。</p>
<p>多依赖值和4NF：</p>
<p>多依赖值：设有R(U)，X、Y是U的子集，Z=U-X-Y。多值依赖X→→Y成立，当且仅当R的任一具体关系r，给定一对(X、Y)值，就有一组Y值与之对应，且这种对应关系与Z值无关。</p>
<p>性质：</p>
<p>(1)若X→→Y，必有X→→U-X-Y。</p>
<p>(2)若X→Y，则必有X→→Y，即X→Y，是X→→Y的特例。</p>
<p>4NF：关系模式R(U)∈1NF，若对R的每个非平凡多值依赖X→→Y(Y⫋X)，X都包含码，则称R(U)满足第四范式，记为R∈4NF。</p>
<hr>
<p>关系规范化的主要目的：</p>
<p>(1)消除异常现象。</p>
<p>(2)方便用户使用，简化检索操作。关系中的每一数据项应是一个简单的数或符号串，而不是一组数或一个重复组。</p>
<p>(3)增强数据独立性，即当引入新数据项时，减少对原有数据结构的修改。</p>
<p>(4)使关系模式更加灵活，更容易使用非过程化的高级查询语言。</p>
<p>(5)更容易进行各种查询统计工作。</p>
<hr>
<h2 id="创建表启用全文搜索（子语句）"><a href="#创建表启用全文搜索（子语句）" class="headerlink" title="创建表启用全文搜索（子语句）"></a>创建表启用全文搜索（子语句）</h2><p>1.建立索引</p>
<p><strong>create [unique] [cluster] index &lt;索引名&gt; on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;]]…)</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create unique index stu_idx_sno on 学生(学号);   &#x2F;&#x2F;为学生建立索引</span><br><span class="line">create unique index cou_idx_cno on 课程(课程号);  &#x2F;&#x2F;为课程建立索引</span><br><span class="line">create unique index sc_idx_sno_cno on 学习(学号 ASC,课程表 DESC); &#x2F;&#x2F;为学习表建立索引</span><br></pre></td></tr></table></figure>

<p>2.删除索引</p>
<p><strong>drop index &lt;索引名&gt;;</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index stu_idx_sno;     &#x2F;&#x2F;删除学生表上的学号上建立的索引</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="撤销表格-撤销数据库中已经存在的表"><a href="#撤销表格-撤销数据库中已经存在的表" class="headerlink" title="撤销表格(撤销数据库中已经存在的表)"></a>撤销表格(撤销数据库中已经存在的表)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 条件];		&#x2F;&#x2F;仅删除表数据，可以回滚</span><br><span class="line">drop table table_name;			&#x2F;&#x2F;连表数据和表结构一起删除，不可回滚</span><br><span class="line">truncate table 表名;				&#x2F;&#x2F;仅删除表数据，不可回滚</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建自动加ID"><a href="#创建自动加ID" class="headerlink" title="创建自动加ID"></a>创建自动加ID</h2><p>执行<code>auto_increment</code>任务，默认开始值为1，每条新纪录递增1。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test (</span><br><span class="line"></span><br><span class="line">            aid int not null auto_increment,</span><br><span class="line"></span><br><span class="line">            site_id int, cout int, date date,</span><br><span class="line"></span><br><span class="line">            primary key (aid) );</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="unique作用"><a href="#unique作用" class="headerlink" title="unique作用"></a>unique作用</h2><ul>
<li><p>unique惟一索引的作用是：保证各行在该索引上的值都不得重复</p>
<p>unique起到取值唯一的作用</p>
</li>
</ul>
<h2 id="一个关系模式能否没有关键字？为什么？"><a href="#一个关系模式能否没有关键字？为什么？" class="headerlink" title="一个关系模式能否没有关键字？为什么？"></a>一个关系模式能否没有关键字？为什么？</h2><ul>
<li>不可以没有关键字，因为关键字是元组的唯一标志，如果没有关键字则无法唯一标识一个元组。</li>
</ul>
<h2 id="什么是数据库设计？试述数据库设计的步骤。"><a href="#什么是数据库设计？试述数据库设计的步骤。" class="headerlink" title="什么是数据库设计？试述数据库设计的步骤。"></a>什么是数据库设计？试述数据库设计的步骤。</h2><p>数据库设计：</p>
<p>数据库设计是指对于一个给定的应用环境，根据用户的需求。在某一具体的数据库管理系统上，构造一个性能良好的数据模式。建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的信息需求和处理需求。</p>
<p>步骤：</p>
<ul>
<li>需求分析阶段</li>
<li>概念结构设计阶段</li>
<li>逻辑结构设计阶段</li>
<li>数据库物理设计阶段</li>
<li>数据库实施阶段</li>
<li>数据库运行和维护阶段</li>
</ul>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p>将一组数据库操作打包起来形成一个逻辑独立的工作单元。这个工作单元不可分割，其中包含的数据库操作要么全部都发生，要么全部都不发生。</p>
<p>例如：在关系数据库(关系数据库是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据。)中，一个事务可以是一条SQL语句结构化查询语言简称SQL，结构化查询语言是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；sql 语句就是对数据库进行操作的一种语言。)，一组SQL语句或整个程序。</p>
<h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul>
<li><p>原子性</p>
</li>
<li><p>一致性</p>
</li>
<li><p>隔离性</p>
</li>
<li><p>持久性</p>
</li>
</ul>
<hr>
<h2 id="数据库系统的故障"><a href="#数据库系统的故障" class="headerlink" title="数据库系统的故障"></a>数据库系统的故障</h2><ul>
<li><p>事务内部故障            //影响事务的正常执行</p>
</li>
<li><p>系统故障                   //影响事务的正常执行</p>
</li>
<li><p>介质故障                   //影响事务的正常执行，破坏数据库的数据</p>
</li>
<li><p>计算机病毒               //破坏数据库的数据</p>
</li>
</ul>
<h2 id="例7-1（P229）"><a href="#例7-1（P229）" class="headerlink" title="例7-1（P229）"></a>例7-1（P229）</h2><p>假定需要在学生数据库(StudentDB)中创建一张学生表，要求包括学生的标识信息(id,自增)，学号(code,varchar(10),主键)，姓名(name,varchar(20)，非空)，性别(sex,varchar(2))，出生日期(birth,date)，所在学院(school,varchar(20),非空)，所在班级(class,varchar(10),非空)，户籍所在地(localtion,varchar(16),非空)，入学成绩(score,float,非空,默认值为0)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table student(id int not null auto_increment primary key,</span><br><span class="line">				code varchar(10) not null,</span><br><span class="line">				name varchar(20) not null,</span><br><span class="line">				sex varchar(2),</span><br><span class="line">				birth date,</span><br><span class="line">				school varchar(20) not null,</span><br><span class="line">				class varchar(10) not null,</span><br><span class="line">				location varchar(16) not null,</span><br><span class="line">				score float not null default 0.0,</span><br><span class="line">				unique index codeidx (code asc)</span><br><span class="line">				);</span><br></pre></td></tr></table></figure>

<p>查看索引是否被使用：</p>
<p>*<em>explain select * from 表名 where 索引名 ;*</em></p>
<p>创建空间索引：</p>
<p><strong>spatial index</strong> 索引名（属性名）;</p>
<p>在已经存在的表上创建索引：</p>
<p><strong>create [unique|fulltext| sratial ] index 索引名 on 表名 (属性名[(长度)] [asc|desc]) ;</strong></p>
<p>在已经存在的表上，用alter table 语句来创建索引：</p>
<p><strong>alter table 表名 add [unique |fulltext| spatial] index 索引名（属性名[(长度)] [asc|desc]）</strong></p>
<p>删除索引：</p>
<p><strong>drop index 索引名 on 表名</strong></p>
<p>关于E-R图，多看看P21的例题，目前不知道咋总结，注意关系之间的图形。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>VC++复习——C++语言面向对象编程基础</title>
    <url>/post/12682.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="VC-复习"><a href="#VC-复习" class="headerlink" title="VC++复习"></a>VC++复习</h1><a id="more"></a>

<p>​    VC++是面向对象的可视化集成编程系统。</p>
<hr>
<h2 id="C-语言面向对象编程基础"><a href="#C-语言面向对象编程基础" class="headerlink" title="C++语言面向对象编程基础"></a>C++语言面向对象编程基础</h2><h3 id="1-一个简单的C-语言程序"><a href="#1-一个简单的C-语言程序" class="headerlink" title="1.一个简单的C++语言程序"></a>1.一个简单的C++语言程序</h3><p><strong>main是主函数名</strong>，函数体用一对大括号括住，函数是C++语言程序里最小的功能单位。</p>
<p>C++语言程序里**必须有且只能有一个函数main( )**，它是程序执行的入口。</p>
<p>C++语言所有语句最后都应当有一个分号。</p>
<hr>
<h3 id="2-C-语言程序基本要素"><a href="#2-C-语言程序基本要素" class="headerlink" title="2.C++语言程序基本要素"></a>2.C++语言程序基本要素</h3><p>C++语言的字符集：</p>
<p>(1)英文字母：A ~ Z,a ~ z。</p>
<p>(2)数字字符：0~9。</p>
<p>(3)特殊字符：空格、！、#、%、^、&amp;、*、_、+、=、-、~、&lt;、&gt;、/、\、‘、”、；、.、，、()、[]、{}。</p>
<p>关键字全部由小写字母组成。</p>
<hr>
<p>标识符是软件开发者自己声明的单词，用于命名一些实体，如函数名、变量名、类名、对象名等。构成规则：</p>
<p>(1)以大写字母、小写字母或下画线开头。</p>
<p>(2)可由大写字母、小写字母、下画线或数字组成。</p>
<p>(3)字母区分大小写，大写字母和小写字母表示不同的标识符。</p>
<p>(4)不能用C++语言的关键字。</p>
<p>尽量<strong>不用下画线开头，</strong>避免与系统定义的关键字冲突。</p>
<hr>
<p>分隔符不进行实际操作，只是用于构造程序。</p>
<p>数据类型指明<strong>变量或表达式的状态和行为，</strong>决定了<strong>数的取值范围和允许执行的运算符集。</strong>可分为<strong>基本类型</strong>和<strong>引用类型</strong>两大类。</p>
<p>基本类型是指<strong>不能再分解</strong>的数据类型，其数据在函数的调用中是以<strong>传值方式</strong>工作的。</p>
<p>unsigned (int)    无符号整型</p>
<p>(signed) int    有符号整型</p>
<hr>
<p>换行符 \n    回车符 \r    水平制表符(Tab键) \t</p>
<hr>
<p>变量：先定义，后使用</p>
<p>使用变量之前必须先声明它的类型和名称</p>
<p>例如：int和float的声明变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num;</span><br><span class="line">float a;</span><br></pre></td></tr></table></figure>

<p>常量：const  &lt;数值类型&gt; &lt;常量名&gt;</p>
<p><code>const float pi=3.1415926</code></p>
<hr>
<p><strong>基本运算符</strong>：+、-、*、/、%。(-作为负号时为一元运算符，作为减号时为二元运算符)</p>
<p>前置后置：i++是后置；–i是前置。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i&#x3D;5,j&#x3D;5,m,n;</span><br><span class="line">m&#x3D;i++;	&#x2F;&#x2F;后置++；相当于m&#x3D;1；i&#x3D;i+1；结果：i&#x3D;6；m&#x3D;5</span><br><span class="line">n&#x3D;++j;	&#x2F;&#x2F;前置++；相当于j&#x3D;j+1；n&#x3D;j；结果：j&#x3D;6，n&#x3D;6</span><br></pre></td></tr></table></figure>

<p><strong>赋值运算符</strong>：=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。    结合性从右向左。例如：</p>
<p><code>a=3+(c=4)</code>        这个表达式的值为7，a=7，c=4。</p>
<p><strong>逗号运算符</strong>：(例如)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c&#x3D;b&#x3D;(a&#x3D;3,4*3);		&#x2F;&#x2F;结果为：a&#x3D;3，b&#x3D;12，c&#x3D;12，表达式值为12</span><br><span class="line">c&#x3D;b&#x3D;a&#x3D;3,4*3;		&#x2F;&#x2F;结果为：a&#x3D;3，b&#x3D;3，c&#x3D;3，表达式值为12</span><br><span class="line">c&#x3D;(b&#x3D;a&#x3D;3,4*3);		&#x2F;&#x2F;结果为：a&#x3D;3，b&#x3D;3，c&#x3D;12，表达式值为12</span><br></pre></td></tr></table></figure>

<p><strong>关系运算符</strong>：&lt;、&lt;=、&gt;、&gt;=、==、!=。前四个优先级相同，后两个优先级相同。前四个优先级比后两个优先级高。</p>
<p><strong>逻辑运算符</strong>：!(非)、&amp;&amp;(与)、||(或)。优先级依此降低。(&amp;与|同时运算)</p>
<p><strong>条件运算符</strong>：C++语言唯一的**<em>三元运算符**</em>。例如：</p>
<p><code>(a&lt;b)?a:b</code>    a:b表示如果a&lt;b，那么结果为a；如果a&gt;b，那么结果为b。</p>
<p><strong>sizeof运算符</strong>：计算某个对象在内存中占用的字节数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof(int);				&#x2F;&#x2F;值为4</span><br><span class="line">double x; sizeof(x);		&#x2F;&#x2F;值为8</span><br></pre></td></tr></table></figure>

<hr>
<p>表达式中的类型转换分为：<strong>隐含转换</strong>和<strong>强制转换</strong>。</p>
<p>隐含转换是安全的，因为没有精度损失。</p>
<p>隐含转换原则：将低类型数据转换为高类型数据。</p>
<p>从低到高的顺序：char、short、int、unsigned int、long、unsigned long、float、double。类型越高，范围越大，精度也越高。</p>
<p>赋值运算要求赋值运算符左边的值和右边的值类型相同，不同的话，会进行自动转换，将一律将右边的值类型转换为左边的值类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i; float f; double d;</span><br><span class="line">d&#x3D;i*f;		&#x2F;&#x2F;计算时现将i转换为f一样的浮点型的值，乘法结果再转换为双精度浮点型的值。</span><br></pre></td></tr></table></figure>

<h2 id="3-类与对象"><a href="#3-类与对象" class="headerlink" title="3.类与对象"></a>3.类与对象</h2><p>面向对象程序设计理论角度：类是对某一类对象的抽象，而对象是对类的具体实例。</p>
<p>程序设计的角度：类是一种复杂的自定义数据类型，对象是属于这种类型的变量。</p>
<hr>
<p><strong>抽象</strong>：对象进行概括，抽出一类对象的共性并加以描述的过程。  有两方面：<strong>数据抽象</strong>和<strong>行为抽象</strong>。</p>
<p><strong>数据抽象</strong>：属性和状态。        <strong>行为抽象</strong>：共同行为或共同功能。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时钟(clock)</span><br><span class="line">数据抽象:</span><br><span class="line">int Hour; int Minute; int Second;</span><br><span class="line">行为抽象:</span><br><span class="line">ShowTime(); SetTime();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VC++</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee仓库</title>
    <url>/post/4e62faf5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="关于gitee仓库的建立"><a href="#关于gitee仓库的建立" class="headerlink" title="关于gitee仓库的建立"></a>关于gitee仓库的建立</h2><a id="more"></a>

<p>注册好gitee账号登录后</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821141508.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821141825.png"></p>
<p>然后点击创建</p>
]]></content>
      <categories>
        <category>gitee</category>
      </categories>
      <tags>
        <tag>Hexo+Gitee+Node.js搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Git安装</title>
    <url>/post/2dbf7e22.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git简易安装流程"><a href="#Git简易安装流程" class="headerlink" title="Git简易安装流程"></a>Git简易安装流程</h2><a id="more"></a>

<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821131900.png"></p>
<p>下载完成之后，傻瓜式安装，因为我已经安装好了，所以这部分没有配安装过程图片。大致分为如下步骤：</p>
<p>1.Next 安装</p>
<p>2.选择安装目录，并点击Next(如果觉得影响电脑运行速度，可以不安装在C盘)</p>
<p>3.选择组件 </p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821132738.png"></p>
<p>(Addtional icons是桌面图标，视个人喜好情况选择)</p>
<p>4.开始菜单的目录名设置 (如果对这些没什么要求的话，直接点Next就行)</p>
<p>5.选择命令行的环境</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821133025.png"></p>
<p>(一般选这个，这个是Git自带命令行工具，第二个是Windows命令行工具，第三个是两者都有)</p>
<p>6.以下几步直接默认即可</p>
<p>7.检查是否安装成功 鼠标右击，出现Git GUI Here和Git Bash Here则安装成功</p>
<h2 id="Git的初始化"><a href="#Git的初始化" class="headerlink" title="Git的初始化"></a>Git的初始化</h2><p>首先通过下面命令查看git版本</p>
<p> #git –version</p>
<p>​    在开始使用Git之前，我们首先要用git config命令设置一下git的配置变量，主要有以下几步：</p>
<p>   （1）配置姓名，这个将在提交的时候用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#git config --global user.name “pang”</span><br><span class="line">#git config --global user.email pang@126.com</span><br></pre></td></tr></table></figure>

<p>然后检查以下是否配置成功</p>
<p>​    （2）设置一些别名，以便使用更为简洁的子命令</p>
<p> #git config –global alias.ci commit</p>
<p>​    （3）开启颜色显示</p>
<p> #git config –global color.ui true</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git安装</tag>
      </tags>
  </entry>
  <entry>
    <title>修改电脑的DNS</title>
    <url>/post/c2fc7544.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关于电脑DNS的修改"><a href="#关于电脑DNS的修改" class="headerlink" title="关于电脑DNS的修改"></a>关于电脑DNS的修改</h1><a id="more"></a>

<p>  之前在搭建博客的时候，发现了电脑没有办法打开GitHub之类的网站，以及没有办法打开Next的使用文档</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822090320.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822090628.png"></p>
<p>  所以我只能转战gitee，但是我发现每次部署完之后，打开发现没有css和js</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822090912.png"></p>
<p>于是，我去问了一些人，终于找到了一个这样的方法——修改电脑的DNS</p>
<hr>
<h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><h3 id="1-打开控制面板"><a href="#1-打开控制面板" class="headerlink" title="1.打开控制面板"></a>1.打开控制面板</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091212.png"></p>
<h3 id="2-打开网络和共享中心"><a href="#2-打开网络和共享中心" class="headerlink" title="2.打开网络和共享中心"></a>2.打开网络和共享中心</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091358.png" alt="image-20200822091357982"></p>
<h3 id="3-打开更改适配器设置"><a href="#3-打开更改适配器设置" class="headerlink" title="3.打开更改适配器设置"></a>3.打开更改适配器设置</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091430.png"></p>
<h3 id="4-打开WLAN属性"><a href="#4-打开WLAN属性" class="headerlink" title="4.打开WLAN属性"></a>4.打开WLAN属性</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091528.png"></p>
<h3 id="5-双击IPv4-取消勾选IPv6"><a href="#5-双击IPv4-取消勾选IPv6" class="headerlink" title="5.双击IPv4 取消勾选IPv6"></a>5.双击IPv4 取消勾选IPv6</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091703.png"></p>
<h3 id="6-使用下面的DNS服务器地址"><a href="#6-使用下面的DNS服务器地址" class="headerlink" title="6.使用下面的DNS服务器地址"></a>6.使用下面的DNS服务器地址</h3><p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822091823.png" alt="image-20200822091823427"></p>
<p>首选DNS服务器： <code>114.114.114.114</code></p>
<p>备用DNS服务器：<code>8.8.8.8</code></p>
<p>这个地址是我从网上看到的</p>
<hr>
<p>  然后，我们就可以发现NexT文档和GitHub的网址都能使用了。</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822092041.png"></p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>修改DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>快速下载网盘神器</title>
    <url>/post/62944.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="亿寻"><a href="#亿寻" class="headerlink" title="亿寻"></a>亿寻</h1><a id="more"></a>

<p>平时需要在网盘下载东西时，发现下载的东西很慢有木有，有时候一个连接不稳定还得重新下载，属实让人难受。</p>
<p>所以，这里推一款软件——亿寻。附上网盘地址：</p>
<p>链接：<a href="https://pan.baidu.com/s/19wDLbDDiEnnOPgkI821c1g">https://pan.baidu.com/s/19wDLbDDiEnnOPgkI821c1g</a><br>提取码：3q6h</p>
<p>下载后，解压发现电脑提示有病毒的话，关掉安全管家就行了，如果安全管家太强大，比如我的安全管家就会把亿寻的exe程序删除，以至于我只有文件，没有启动程序，那么，就保留压缩的文件，到需要的时候，就仅仅解压exe文件即可</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200823212322.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200823212749.png" alt="image-20200823212748976"></p>
]]></content>
      <tags>
        <tag>--网盘神器 --网盘文件助手</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo博客——GitHub篇</title>
    <url>/post/fb98ceba.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-GIT-Node-js搭建博客"><a href="#Hexo-GIT-Node-js搭建博客" class="headerlink" title="Hexo+ GIT+Node.js搭建博客"></a><a href="http://zsquw5.coding-pages.com/2020/08/20/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94Gitee%E7%AF%87/">Hexo+ GIT+Node.js搭建博客</a></h1><a id="more"></a>

<p>软件准备工作和之前的  搭建hexo博客——Gitee篇  一样，点击标题即可转接。</p>
<h2 id="正文开始-以下命令都是在git中执行"><a href="#正文开始-以下命令都是在git中执行" class="headerlink" title="正文开始(以下命令都是在git中执行)"></a>正文开始(以下命令都是在git中执行)</h2><p>在本地建立一个文件夹，这个文件夹就是搭建hexo博客的开始。我的文件夹名字叫(博客)，便于理解。</p>
<p>在博客内打开Git，就是Git Bash Here，输入：</p>
<p><code>hexo init</code></p>
<p>然后开始一段时间的等待……</p>
<p>加载完成之后，你可以输入</p>
<p><code>hexo s</code>        查看当前网站(注意：这是在本地4000端口查看的，不是网上能查出来的，是需要部署之后才能查看)</p>
<hr>
<p>之前说的不能查看GitHub相关的网站，我也在修改DNS中有提到过解决方法。</p>
<p><a href="https://solitudehero.github.io/2020/08/22/%E4%BF%AE%E6%94%B9%E7%94%B5%E8%84%91%E7%9A%84DNS/#more">DNS修改</a></p>
<p>ok，废话不多说，上干货。</p>
<hr>
<p>同样的，需要首先去<a href="https://github.com/">GitHub官网</a>那去创建一个仓库</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822195521.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822195721.png"></p>
<p>一般情况下，完成后，会返回你一个仓库地址值，如果没有返回也不要着急，在这也可以找到</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822195915.png" alt="image-20200822195914713"></p>
<p>在 Blog 目录下安装一个 hexo 部署插件 </p>
<p><code>cnpm install --save hexo-deployer-git</code></p>
<p>找到 Blog 文件中的 _config.yml 文件，使用工具打开，如果不是很熟练，建议使用Visual Studio Code 打开，当然，如果觉得麻烦，也可以笔记本打开，但是容易出现错误。</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821142432.png"></p>
<p>找到这行代码repo后输入接上刚刚让你复制的仓库地址。</p>
<p>然后进行保存。</p>
<p>在博客目录下打开的git里面输入<code>hexo d</code></p>
<p>然后，你就可以直接打开自己的网址了，不需要再去Github上面部署了。</p>
<p>等等……什么？你不知道网址？</p>
<p>在这里</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822200115.png" alt="image-20200822200115078"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822200156.png" alt="image-20200822200156187"></p>
<p>如果你第一次勾选了那个README(就是创建仓库的时候)，你们会自动生成，如果没有勾选，按照我的这个设置之后，按save即可获取</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200822200231.png" alt="image-20200822200231115"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo+Github+Node.js搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo博客——Gitee篇</title>
    <url>/post/c04ba748.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-Git-Node-js搭建博客"><a href="#Hexo-Git-Node-js搭建博客" class="headerlink" title="Hexo+Git+Node.js搭建博客"></a>Hexo+Git+Node.js搭建博客</h1><a id="more"></a>

<p>  经过了三天过程中的十几次搭建，最终对一些优化放弃了继续的挣扎，next的版本高，一些东西不会操作，导致重新开始，也算是小有心得，写下来当做第一篇博客！</p>
<h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><p>(1) Git下载：</p>
<p><a href="https://git-scm.com/">官网</a></p>
<p><a href="npm.taobao.org/mirrors/git-for-windows">国内</a></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821125321.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821125940.png"></p>
<p><a href="https://solitudehero.github.io/2020/08/21/git%E5%AE%89%E8%A3%85/#more">Git安装</a></p>
<p><a href="https://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html">Git配置</a>(我是看网上的)</p>
<p>(2)<a href="https://nodejs.org/en/">Node.js安装</a></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821135324.png"></p>
<p>傻瓜式安装即可！</p>
<p>(3)安装Hexo</p>
<p>打开Git Bash Here</p>
<hr>
<p>检测node是否安装成功</p>
<p>node -v    (返回版本号)</p>
<p>npm -v     (返回版本号)</p>
<hr>
<p>安装淘宝镜像源</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>检测</p>
<p>cnpm         (返回 cnpm 的信息)</p>
<p>cnpm -v     (返回 cnpm 的版本信息)</p>
<hr>
<p>安装hexo</p>
<p><code>cnpm install -g hexo-cli</code></p>
<p>hexo -v    (返回hexo的版本信息)</p>
<h2 id="正文开始-以下命令都是在git中执行"><a href="#正文开始-以下命令都是在git中执行" class="headerlink" title="正文开始(以下命令都是在git中执行)"></a>正文开始(以下命令都是在git中执行)</h2><p>在本地建立一个文件夹，这个文件夹就是搭建hexo博客的开始。我的文件夹名字叫(博客)，便于理解。</p>
<p>在博客内打开Git，就是Git Bash Here，输入：</p>
<p><code>hexo init</code></p>
<p>然后开始一段时间的等待……</p>
<p>加载完成之后，你可以输入</p>
<p><code>hexo s</code>        查看当前网站(注意：这是在本地4000端口查看的，不是网上能查出来的，是需要部署之后才能查看)</p>
<hr>
<p>因为我的电脑不知道什么情况不能查看GitHub相关的网站，所以我用的是Gitee部署的，Gitee是国内版的GitHub，速度相对于GitHub比较快，但是部署时会较GitHub麻烦一点，需要去码云那里更新一次，不然显示不出来更新效果。</p>
<hr>
<p>到gitee那里注册一个账号，然后创建一个仓库即可。不会的可以查看链接。</p>
<p><a href="https://solitudehero.github.io/2020/08/21/gitee%E4%BB%93%E5%BA%93/#more">gitee仓库</a></p>
<p>复制一下仓库URL(就是仓库地址的网址)</p>
<hr>
<p>在 Blog 目录下安装一个 hexo 部署插件 </p>
<p><code>cnpm install --save hexo-deployer-git</code></p>
<p>找到 Blog 文件中的 _config.yml 文件，使用工具打开，如果不是很熟练，建议使用Visual Studio Code 打开，当然，如果觉得麻烦，也可以笔记本打开，但是容易出现错误。</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821142432.png"></p>
<p>找到这行代码repo后输入接上刚刚让你复制的仓库地址。</p>
<p>然后进行保存。</p>
<p>在博客目录下打开的git里面输入<code>hexo d</code></p>
<p>然后再在码云仓库里</p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821142717.png"></p>
<p><img src="https://gitee.com/studynil/boke/raw/master/ing/20200821142755.png"></p>
<p>然后那个网站地址就是你部署的，别人也可以通过搜那个网站进入你的博客了。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo+Gitee+Node.js搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>节点的删除插入等基本操作</title>
    <url>/post/b94a87bf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="节点的删除插入等基本操作"><a href="#节点的删除插入等基本操作" class="headerlink" title="节点的删除插入等基本操作"></a>节点的删除插入等基本操作</h1><a id="more"></a>

<h2 id="Mylink"><a href="#Mylink" class="headerlink" title="Mylink"></a>Mylink</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mylink &#123;</span><br><span class="line">    private Node first;&#x2F;&#x2F;第一个节点</span><br><span class="line">    private Node end;&#x2F;&#x2F;最后一个节点</span><br><span class="line">    private int size;&#x2F;&#x2F;节点个数</span><br><span class="line">    &#x2F;&#x2F;用尾插法增加一个节点</span><br><span class="line">    public void linkListAdd(Object obj) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        Node node &#x3D; new Node(obj);</span><br><span class="line">        if(first&#x3D;&#x3D;null) &#123;</span><br><span class="line">            first &#x3D; node;</span><br><span class="line">            end &#x3D; node;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            end.next &#x3D; node;</span><br><span class="line">            node.previous &#x3D; end;</span><br><span class="line">            end &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;删除一个节点</span><br><span class="line">    public void linkListRemove(int index) &#123;</span><br><span class="line">        if(index&#x3D;&#x3D;0) &#123;</span><br><span class="line">            first&#x3D;first.next;</span><br><span class="line">            first.previous&#x3D;null;</span><br><span class="line">        &#125;else if(index&#x3D;&#x3D;size-1)&#123;</span><br><span class="line">            end&#x3D;end.previous;</span><br><span class="line">            end.next&#x3D;null;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Node temp&#x3D;getNode(index);</span><br><span class="line">            temp.previous.next&#x3D;temp.next;</span><br><span class="line">            temp.next.previous&#x3D;temp.previous;</span><br><span class="line">            temp.next&#x3D;temp.previous&#x3D;null;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;插入一个节点</span><br><span class="line">    public void linkListInsert(Object obj , int index) &#123;</span><br><span class="line">        Node node &#x3D; new Node(obj);</span><br><span class="line">        if(index&#x3D;&#x3D;0) &#123;</span><br><span class="line">            first.previous&#x3D;node;</span><br><span class="line">            node.next&#x3D;first;</span><br><span class="line">            first&#x3D;node;</span><br><span class="line">        &#125;else if(index&#x3D;&#x3D;size) &#123;</span><br><span class="line">            end.next&#x3D;node;</span><br><span class="line">            end.previous&#x3D;end;</span><br><span class="line">            end&#x3D;node;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Node temp&#x3D;getNode(index);</span><br><span class="line">            node.next&#x3D;temp;</span><br><span class="line">            node.previous&#x3D;temp.previous;</span><br><span class="line">            temp.previous.next&#x3D;node;</span><br><span class="line">            temp.previous&#x3D;node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回特定下标的节点</span><br><span class="line">    public Node getNode(int index) &#123;</span><br><span class="line">        if(index&lt;0||index&gt;size-1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;索引不合法：&quot;+index);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp&#x3D;null;</span><br><span class="line">        if(index&lt;&#x3D;(size&gt;&gt;1)) &#123;</span><br><span class="line">            temp &#x3D; first;</span><br><span class="line">            for(int i&#x3D;0 ; i&lt;index ; i++) &#123;</span><br><span class="line">                temp &#x3D; temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            temp &#x3D; end;</span><br><span class="line">            for(int i&#x3D;size-1 ; i&gt;index ; i--) &#123;</span><br><span class="line">                temp &#x3D; temp.previous;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;取得指定下表的节点的内容</span><br><span class="line">    public Object get(int index) &#123;</span><br><span class="line">        Node temp &#x3D; getNode(index);</span><br><span class="line">        return temp&#x3D;&#x3D;null?null:temp.element;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Mylink linklist &#x3D; new Mylink();</span><br><span class="line">        linklist.linkListAdd(&quot;a&quot;);</span><br><span class="line">        linklist.linkListAdd(&quot;b&quot;);</span><br><span class="line">        linklist.linkListAdd(&quot;c&quot;);</span><br><span class="line">        linklist.linkListAdd(&quot;d&quot;);</span><br><span class="line">        linklist.linkListAdd(&quot;e&quot;);</span><br><span class="line">        System.out.print(linklist);&#x2F;&#x2F;abcde</span><br><span class="line">        System.out.println(&quot;链表的长度为：&quot;+linklist.size);&#x2F;&#x2F;链表的长度为：5</span><br><span class="line">        System.out.println(&quot;从链表中取得的元素为：&quot;+linklist.get(4));&#x2F;&#x2F;从链表中取得的元素为：e</span><br><span class="line">        linklist.linkListRemove(3);</span><br><span class="line">        System.out.print(linklist);&#x2F;&#x2F;abce</span><br><span class="line">        linklist.linkListInsert(&quot;f&quot;, 4);</span><br><span class="line">        System.out.println(linklist);&#x2F;&#x2F;abcef</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打印链表，改写toString方法</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        Node temp &#x3D; first;</span><br><span class="line">        while(temp!&#x3D;null) &#123;</span><br><span class="line">            System.out.print(temp.element);</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    Node previous;</span><br><span class="line">    Node next;</span><br><span class="line">    Object element;</span><br><span class="line">    public Node(Object o)&#123;</span><br><span class="line">        this.element &#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>-Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title>英语六级笔记整理</title>
    <url>/post/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="英语六级笔记整理"><a href="#英语六级笔记整理" class="headerlink" title="英语六级笔记整理"></a>英语六级笔记整理</h3><p>bilibili看后总结   <a href="https://www.bilibili.com/video/BV1Ca4y177Zm/?spm_id_from=333.788.videocard.0">这里是原视频地址</a>（四级的也可以看这个视频）</p>
<h2 id="时间规划以及顺序方面"><a href="#时间规划以及顺序方面" class="headerlink" title="时间规划以及顺序方面"></a>时间规划以及顺序方面</h2><p>1.写作 （30分钟，建议&lt;25分钟）</p>
<p>2.听力   （30分钟）</p>
<p>3.仔细阅读</p>
<p>4.长篇阅读</p>
<p>5.翻译  （30分钟，建议&lt;25分钟）</p>
<p>6.选词填空</p>
<h2 id="内容方面"><a href="#内容方面" class="headerlink" title="内容方面"></a>内容方面</h2><h3 id="1-写作"><a href="#1-写作" class="headerlink" title="1.写作"></a>1.写作</h3><p>分类：论说文，谚语警句，图画图表，书信。</p>
<p>1.常见土单词排行榜：</p>
<ol>
<li>think:</li>
</ol>
<p>a.have been convinced that</p>
<p>b.be of the opinion that</p>
<p>c.cling to the perspective that</p>
<ol start="2">
<li>many:</li>
</ol>
<p>a.a sea of</p>
<p>b.multitudes of</p>
<p>c.immense</p>
<p>d.amounts of</p>
<ol start="3">
<li>people we us  要求单词准确</li>
</ol>
<p>a.private individuals</p>
<p>b.younters and teenagers</p>
<p>c.all children and adults</p>
<p>d.experts and professors</p>
<p>e.parents kids offspring</p>
<p>f.youngters on campus</p>
<ol start="4">
<li>very</li>
</ol>
<p>a.exceedingly</p>
<p>b.distinctly</p>
<p>c.more than</p>
<ol start="5">
<li>important</li>
</ol>
<p>a.significant</p>
<p>b.crucial</p>
<p>c.play a crucial role in sth.</p>
<h2 id="2-写作中可用的万能句型"><a href="#2-写作中可用的万能句型" class="headerlink" title="2.写作中可用的万能句型"></a>2.写作中可用的万能句型</h2><p>1） 主语从句：（记住三个左右就差不多了）</p>
<p>a.It proves self-evident that </p>
<p>b.It have been found that</p>
<p>c.It becomes my point that</p>
<p>d.It seems universally acknowledged that</p>
<ol start="2">
<li>定语从句 (which 引导的非限制性定语从句可以修饰前面的整句话(此时which翻译成：“这”))</li>
</ol>
<p>他是一个色狼，是显而易见的(a、b、c随便选一个)</p>
<p>He is a lady killer,</p>
<p>a.which is really beyond dispute</p>
<p>b.which has been widely accepted</p>
<p>c.which has provoked the public’s widespread concern</p>
<p>3)万能状语</p>
<p>1.as every one can see it</p>
<p>2.with the rapid advance of science and technology</p>
<p>3.in our contemporary society</p>
<p>4.in the general routine of everyday living</p>
<p>4)万能插入语（选一个）（推荐：某一段的段首句主谓之间）</p>
<ul>
<li><p>to be frank；needless to say</p>
</li>
<li><p>in my judgment</p>
</li>
<li><p>from my perspective</p>
</li>
<li><p>to tell the trut</p>
</li>
<li><p>as a matter of fact</p>
</li>
</ul>
<p>5)强调句型</p>
<ul>
<li>It is … that…</li>
</ul>
<h2 id="3-文章"><a href="#3-文章" class="headerlink" title="3.文章"></a>3.文章</h2><p>一、引出主题+个人观点</p>
<p>二、原因分析或举例</p>
<p>三、总结</p>
<h2 id="4-翻译"><a href="#4-翻译" class="headerlink" title="4.翻译"></a>4.翻译</h2><p>要求：基本表达原文意思，文字通顺连贯，无重大语言错误</p>
<p>不会的单词：</p>
<p>1.上位词</p>
<p>2.同义词</p>
<p>3.用会用的单词解释</p>
<p>4.大词瞎写，小词装没看见</p>
<h3 id="英汉差异对比"><a href="#英汉差异对比" class="headerlink" title="英汉差异对比"></a>英汉差异对比</h3><h4 id="1-汉语意合，英语形合"><a href="#1-汉语意合，英语形合" class="headerlink" title="1.汉语意合，英语形合"></a>1.汉语意合，英语形合</h4><p>and：at the same time</p>
<p>but：on the contrary</p>
<p>so：as a result</p>
<p>then：in addition（moreovre）</p>
<h4 id="2-英语被动，汉语主动"><a href="#2-英语被动，汉语主动" class="headerlink" title="2.英语被动，汉语主动"></a>2.英语被动，汉语主动</h4><h4 id="3-英语长句，汉语短句"><a href="#3-英语长句，汉语短句" class="headerlink" title="3.英语长句，汉语短句"></a>3.英语长句，汉语短句</h4><p>1.非谓语动词</p>
<p>2.从句</p>
<p>3.逻辑关系词</p>
<h3 id="翻译步骤"><a href="#翻译步骤" class="headerlink" title="翻译步骤"></a>翻译步骤</h3><p>1.以意群为单位读句子，确定句子时态</p>
<p>2.确定句子主干，非主干部分用定语和状语翻译</p>
<p>3.上下句逻辑关系，加逻辑关系词</p>
<h2 id="仔细阅读"><a href="#仔细阅读" class="headerlink" title="仔细阅读"></a>仔细阅读</h2><p>1.时间：8-10分钟一篇</p>
<p>2.原则：</p>
<p>​    1)读首段和各段首句，把握文章中心（两分钟读完）</p>
<p>​    2)顺序原则</p>
<p>3.题型分析</p>
<p>​    主旨题</p>
]]></content>
      <categories>
        <category>英语六级</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>六级</tag>
      </tags>
  </entry>
  <entry>
    <title>酒店管理系统代码</title>
    <url>/post/6348d4b5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="酒店管理系统代码"><a href="#酒店管理系统代码" class="headerlink" title="酒店管理系统代码"></a>酒店管理系统代码</h1><h2 id="1-Room类"><a href="#1-Room类" class="headerlink" title="1.Room类"></a>1.Room类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">&#x2F;&#x2F;关于酒店房间的设置</span><br><span class="line">public class Room &#123;</span><br><span class="line">        &#x2F;&#x2F;房间编号</span><br><span class="line">        private int no;</span><br><span class="line">        &#x2F;&#x2F;房间类型</span><br><span class="line">        private String type;</span><br><span class="line">        &#x2F;&#x2F;房间状态</span><br><span class="line">        private boolean status;</span><br><span class="line">        &#x2F;&#x2F;构造方法</span><br><span class="line">        public Room()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public Room(int no,String type,boolean status)&#123;</span><br><span class="line">            this.no&#x3D;no;</span><br><span class="line">            this.type&#x3D;type;</span><br><span class="line">            this.status&#x3D;status;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;setter and getter</span><br><span class="line">        public int getNo() &#123;</span><br><span class="line">            return no;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setNo(int no) &#123;</span><br><span class="line">            this.no &#x3D; no;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getType() &#123;</span><br><span class="line">            return type;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setType(String type) &#123;</span><br><span class="line">            this.type &#x3D; type;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean getStatus() &#123;</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setStatus(boolean status) &#123;</span><br><span class="line">            this.status &#x3D; status;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;toString重写</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;[&quot; + no + &quot;,&quot; + type + &quot;,&quot; + (status ? &quot;空闲&quot; : &quot;占用&quot;) + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;equals重写</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (o &#x3D;&#x3D; null || !(o instanceof Room)) return false;</span><br><span class="line">            if(this &#x3D;&#x3D; o) return true;</span><br><span class="line">            Room room &#x3D; (Room) o;</span><br><span class="line">            return this.getNo() &#x3D;&#x3D; room.getNo();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Hotel类"><a href="#2-Hotel类" class="headerlink" title="2.Hotel类"></a>2.Hotel类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hotel &#123;</span><br><span class="line">    &#x2F;&#x2F;建房</span><br><span class="line">    private Room[][]rooms;</span><br><span class="line">    public Hotel() &#123;</span><br><span class="line">        &#x2F;&#x2F;动态初始化</span><br><span class="line">        rooms &#x3D; new Room[3][10];</span><br><span class="line">        &#x2F;&#x2F;创建数组，遍历</span><br><span class="line">        for (int i &#x3D; 0; i &lt;rooms.length ; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt;rooms[i].length ; j++) &#123;</span><br><span class="line">               if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   &#x2F;&#x2F;一层</span><br><span class="line">                   rooms[i][j] &#x3D; new Room((i+1)*100+j+1,&quot;单人间&quot;,true);</span><br><span class="line">               &#125;else if (i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                   &#x2F;&#x2F;二层</span><br><span class="line">                   rooms[i][j] &#x3D; new Room((i+1)*100+j+1,&quot;标准间&quot;,true);</span><br><span class="line">               &#125;else if (i &#x3D;&#x3D; 2)&#123;</span><br><span class="line">                   &#x2F;&#x2F;三层</span><br><span class="line">                   rooms[i][j] &#x3D; new Room((i+1)*100+j+1,&quot;总统套房&quot;,true);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在酒店对象上提供一个打印房间列表的方法</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; rooms.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; rooms[i].length; j++) &#123;</span><br><span class="line">                Room room &#x3D; rooms[i][j];</span><br><span class="line">                System.out.print(room);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;换行</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;订房方法</span><br><span class="line">    public void order(int roomNo)&#123;</span><br><span class="line">        &#x2F;&#x2F;订房最主要的是将房间对象的status修改为false</span><br><span class="line">        Room room &#x3D; rooms[roomNo &#x2F; 100 - 1][roomNo % 100 - 1];</span><br><span class="line">        &#x2F;&#x2F;修改为占用</span><br><span class="line">        room.setStatus(false);</span><br><span class="line">        System.out.println(roomNo+&quot;已定房！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;退房系统</span><br><span class="line">    public void exit(int roomNo)&#123;</span><br><span class="line">        Room room &#x3D; rooms[roomNo &#x2F; 100 - 1][roomNo % 100 - 1];</span><br><span class="line">        &#x2F;&#x2F;修改为空闲</span><br><span class="line">        room.setStatus(true);</span><br><span class="line">        System.out.println(roomNo+&quot;已退房！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Manage"><a href="#3-Manage" class="headerlink" title="3.Manage"></a>3.Manage</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;关于酒店管理系统</span><br><span class="line">public class Manage &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hotel hotel &#x3D; new Hotel();</span><br><span class="line">        System.out.println(&quot;欢迎使用酒店管理系统，请认真阅读使用说明&quot;);</span><br><span class="line">        System.out.println(&quot;请输入对应的功能编号：[1]表示查看房间列表。[2]标识订房。[3]表示退房。[0]退出系统。&quot;);</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">       while (true)&#123;</span><br><span class="line">           System.out.println(&quot;请输入功能编号：&quot;);</span><br><span class="line">           int i &#x3D; scanner.nextInt();</span><br><span class="line">           if (i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">               hotel.print();</span><br><span class="line">           &#125;else if(i &#x3D;&#x3D; 2)&#123;</span><br><span class="line">               System.out.print(&quot;请输入房间编号：&quot;);</span><br><span class="line">               int roomNo &#x3D; scanner.nextInt();</span><br><span class="line">               hotel.order(roomNo);</span><br><span class="line">           &#125;else if(i &#x3D;&#x3D; 3)&#123;</span><br><span class="line">               System.out.print(&quot;请输入房间编号：&quot;);</span><br><span class="line">               int roomNo &#x3D; scanner.nextInt();</span><br><span class="line">               hotel.exit(roomNo);</span><br><span class="line">           &#125;else if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">               System.out.println(&quot;退出系统！&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               System.out.println(&quot;输入编号有误，请重新输入！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/post/8fe47ff4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="JDBC学习"><a href="#JDBC学习" class="headerlink" title="JDBC学习"></a>JDBC学习</h3><h2 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class jdbc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;1.导入驱动jar包</span><br><span class="line">        &#x2F;&#x2F;2.注册驱动</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        &#x2F;&#x2F;3.获取数据库连接对象</span><br><span class="line">        &#x2F;&#x2F;localhost:3306&#x2F;db3.root,root);</span><br><span class="line">        Connection connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;, &quot;root&quot;, &quot;8023&quot;);</span><br><span class="line">        &#x2F;&#x2F;4.定义sql语言</span><br><span class="line">        String sql &#x3D;&quot;update class set score &#x3D; 100 where id&#x3D; 23&quot;;</span><br><span class="line">        &#x2F;&#x2F;5.获取执行sql的对象 Statement</span><br><span class="line">        Statement statement&#x3D;connection.createStatement();</span><br><span class="line">        &#x2F;&#x2F;6.执行sql</span><br><span class="line">        int i &#x3D; statement.executeUpdate(sql);</span><br><span class="line">        &#x2F;&#x2F;7.处理结果</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        &#x2F;&#x2F;8.释放资源</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="详解各个对象"><a href="#详解各个对象" class="headerlink" title="详解各个对象"></a>详解各个对象</h2><p>1.DriverManager：驱动管理对象</p>
<ul>
<li>功能</li>
</ul>
<p>1.注册驱动：告诉程序该使用哪一个数据驱动jar</p>
<p> static void registerDriver(Driver driver):注册给定的驱动程序 DriverManager。</p>
<p>写代码使用：<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<p><strong>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</strong></p>
<p>2.获取数据库连接：</p>
<ul>
<li><p>方法：<code>Connection connection = DriverManager.getConnection(String url,String user,String password)</code></p>
<p>url：语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</p>
<p>​         细节：如果是连接本地mysql服务器，并且服务器默认端口是3306，则URL可以写成：jdbc:mysql:///数据库名称</p>
</li>
</ul>
<p>2.Connection：数据库连接对象</p>
<ul>
<li><p>功能</p>
<p>1.获取执行sql对象</p>
<p>​    Statement createStatement()</p>
<p>​    PreparedStatement preparedStatement(String sql)</p>
<p>2.管理事务：</p>
<p>​    *开启事务：setAutoCommit(boolean autoCommit)：调用该方法设置参数为false，即为开启事务</p>
<p>​    *提交事务：commit()</p>
<p>​    *回滚事务：rollback()</p>
</li>
</ul>
<p>3.Statement：执行sql的对象</p>
<p>​    1.执行sql</p>
<p>​        1.boolean execute(String sql)：可以执行任意的sql  了解</p>
<p>​        2.int executeUpdate(String sql)：执行DML（insert、update、delete）语句、DDL（create、alter、drop）语句</p>
<p><strong>返回值：影响行数，可以通过这个影响的行数判断DML语句是否执行成功，返回值&gt;0的则执行成功，反之，失败</strong></p>
<p>​        3.ResultSet executeQuery(String sql)：执行DQL(select)语句</p>
<p>​    2.练习：</p>
<p>​        1.stu表 添加一条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class jbdc练习 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        Statement stmt &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.定义sql</span><br><span class="line">            String sql &#x3D;&quot;insert into student values(11,&#39;小四&#39;,&#39;男&#39;,&#39;16&#39;,&#39;河南郑州&#39;)&quot;;</span><br><span class="line">            &#x2F;&#x2F;3.获取Connection对象</span><br><span class="line">            try &#123;</span><br><span class="line">                 connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;,&quot;root&quot;,&quot;8023&quot;);</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql的对象 Statement</span><br><span class="line">                 stmt &#x3D; connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">                int i &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;影响行数</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                if(i&gt;0)&#123;</span><br><span class="line">                    System.out.println(&quot;添加成功！&quot;);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    System.out.println(&quot;添加失败！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;stmt.close();</span><br><span class="line">            &#x2F;&#x2F;7.释放资源</span><br><span class="line">            &#x2F;&#x2F;避免空指针异常</span><br><span class="line">            if(stmt!&#x3D;null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;避免空指针异常</span><br><span class="line">            if(connection!&#x3D;null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>​        2.stu表 修改记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.*;</span><br><span class="line"></span><br><span class="line">public class jdbc练习2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection&#x3D;null;</span><br><span class="line">        Statement stmt&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.获取连接对象</span><br><span class="line">            connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;,&quot;root&quot;,&quot;8023&quot;);</span><br><span class="line">            &#x2F;&#x2F;3.定义sql</span><br><span class="line">            String sql &#x3D; &quot;update stu set score&#x3D;550 where id&#x3D;12&quot;;</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql对象</span><br><span class="line">            stmt&#x3D;connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            int i &#x3D; stmt.executeUpdate(sql);</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            if (i &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;修改成功！&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;修改失败！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (stmt!&#x3D;null)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (connection!&#x3D;null)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        3.stu表 删除记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class jdbc练习3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection&#x3D;null;</span><br><span class="line">        Statement stmt&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.获取连接对象</span><br><span class="line">            connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;,&quot;root&quot;,&quot;8023&quot;);</span><br><span class="line">            &#x2F;&#x2F;3.定义sql</span><br><span class="line">            String sql &#x3D; &quot;delete from student where id&#x3D;11&quot;;</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql对象</span><br><span class="line">            stmt&#x3D;connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            int i &#x3D; stmt.executeUpdate(sql);</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            if (i &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;删除成功！&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;删除失败！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (stmt!&#x3D;null)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (connection!&#x3D;null)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        4.添加一个表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class jdbc练习4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection&#x3D;null;</span><br><span class="line">        Statement stmt&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.获取连接对象</span><br><span class="line">            connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;,&quot;root&quot;,&quot;8023&quot;);</span><br><span class="line">            &#x2F;&#x2F;3.定义sql</span><br><span class="line">            String sql &#x3D; &quot;create table mine (id int , name varchar(20))&quot;;</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql对象</span><br><span class="line">            stmt&#x3D;connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            int i &#x3D; stmt.executeUpdate(sql);</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            if (i &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;删除成功！&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;删除失败！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (stmt!&#x3D;null)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (connection!&#x3D;null)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.ResultSet：结果集对象，封装查询结果</p>
<ul>
<li><p>next()：游标向下移动一行</p>
</li>
<li><p>getXxx：获取数据</p>
<ul>
<li><p>Xxx：代表数据类型      如：int getInt()，String getString()</p>
</li>
<li><p>参数</p>
<p>1.int：代表列的编号，从1开始  如：getString(1)</p>
<p>2.Sting:代表列名称。如：getDouble(“score”)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import com.mysql.cj.protocol.Resultset;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Result;</span><br><span class="line">import java.sql.*;</span><br><span class="line"></span><br><span class="line">public class jdbc练习5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection&#x3D;null;</span><br><span class="line">        Statement stmt&#x3D;null;</span><br><span class="line">        ResultSet r &#x3D; null ;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.获取连接对象</span><br><span class="line">            connection&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;stu?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai&quot;,&quot;root&quot;,&quot;8023&quot;);</span><br><span class="line">            &#x2F;&#x2F;3.定义sql</span><br><span class="line">            String sql &#x3D; &quot;select * from student&quot;;</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql对象</span><br><span class="line">            stmt&#x3D;connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            r &#x3D; stmt.executeQuery(sql);</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            &#x2F;&#x2F;6.1让游标向下移动一行</span><br><span class="line">            r.next();</span><br><span class="line">            &#x2F;&#x2F;6.2获取数据</span><br><span class="line">            int id &#x3D; r.getInt(1);</span><br><span class="line">            String name &#x3D; r.getString(&quot;name&quot;);</span><br><span class="line">            String sex &#x3D; r.getString(&quot;sex&quot;);</span><br><span class="line">            int age &#x3D; r.getInt(4);</span><br><span class="line">            String address &#x3D; r.getString(&quot;address&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(id+&quot; &quot;+name+&quot; &quot;+sex+&quot; &quot;+age+&quot; &quot;+address);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (stmt!&#x3D;null)&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (connection!&#x3D;null)&#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (r!&#x3D;null)&#123;</span><br><span class="line">                    r.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<pre><code> 使用步骤：</code></pre>
<p>​        1.游标向下移动一行</p>
<p>​        2.判断是否有数据</p>
<p>​        3.获取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (r.next()) &#123;</span><br><span class="line">              &#x2F;&#x2F;获取数据</span><br><span class="line">              &#x2F;&#x2F;6.1让游标向下移动一行</span><br><span class="line">              &#x2F;&#x2F;6.2获取数据</span><br><span class="line">              int id &#x3D; r.getInt(1);</span><br><span class="line">              String name &#x3D; r.getString(&quot;name&quot;);</span><br><span class="line">              String sex &#x3D; r.getString(&quot;sex&quot;);</span><br><span class="line">              int age &#x3D; r.getInt(4);</span><br><span class="line">              String address &#x3D; r.getString(&quot;address&quot;);</span><br><span class="line"></span><br><span class="line">              System.out.println(id + &quot; &quot; + name + &quot; &quot; + sex + &quot; &quot; + age + &quot; &quot; + address);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>练习</p>
<ul>
<li><p>查询student表的数据将其封装为对象，然后装在集合，返回。</p>
<p>1.定义student类</p>
<p>2.定义方法public List<student> findAll(){}</p>
<p>3.实现方法 select * from student;</p>
</li>
</ul>
</li>
</ul>
<p>5.PreparedStatement：执行sql的对象</p>
<ul>
<li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题</p>
<ul>
<li>输入用户随便，输入密码：a’ or ‘a’=’a</li>
<li>sql:select * from user where usename=XXX and password=XXX</li>
</ul>
</li>
<li><p>解决sql问题：使用PreparedStement对象来解决</p>
</li>
<li><p>预编译的SQL：参数使用?作为占位符</p>
</li>
</ul>
<h2 id="抽取JDBC工具类-：JDBCUtils"><a href="#抽取JDBC工具类-：JDBCUtils" class="headerlink" title="抽取JDBC工具类 ：JDBCUtils"></a>抽取JDBC工具类 ：JDBCUtils</h2><ul>
<li><p>目的：简化书写</p>
</li>
<li><p>分析：</p>
<p>1.注册驱动也抽取</p>
<p>2.抽取一个方法获取连接对象</p>
<ul>
<li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性</p>
</li>
<li><p>解决：配置文件</p>
<p>jdbc.properties</p>
<p>​    url=</p>
<p>​    user=</p>
<p>​    password=</p>
</li>
</ul>
<p>3.抽取一个方法释放资源</p>
<p>JDBCutils</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.util;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JDBCutils &#123;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String user;</span><br><span class="line">    private static String password;</span><br><span class="line">    private static String driver;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F;读取资源文件，获取值</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.创建Properties集合类</span><br><span class="line">            Properties pr&#x3D;new Properties();</span><br><span class="line">            &#x2F;&#x2F;获取src路径下的文件的方式---&gt;ClassLoader类加载器th);</span><br><span class="line">            &#x2F;&#x2F;2.加载文件</span><br><span class="line">            pr.load(new FileReader(&quot;G:\\JDBC\\jdbc\\src\\jdbc.properties&quot;));</span><br><span class="line">            &#x2F;&#x2F;3.获取数据，赋值</span><br><span class="line">            url &#x3D; pr.getProperty(&quot;url&quot;);</span><br><span class="line">            user &#x3D; pr.getProperty(&quot;user&quot;);</span><br><span class="line">            password &#x3D; pr.getProperty(&quot;password&quot;);</span><br><span class="line">            driver &#x3D; pr.getProperty(&quot;driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;4.注册驱动</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Connection getConnection() throws SQLException&#123;</span><br><span class="line">        return DriverManager.getConnection(url,user,password);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(Statement stmt,Connection connection)&#123;</span><br><span class="line">        if(stmt!&#x3D;null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(connection!&#x3D;null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(ResultSet r, Statement stmt, Connection connection)&#123;</span><br><span class="line">        if(r!&#x3D;null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                r.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(stmt!&#x3D;null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(connection!&#x3D;null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JDB练习</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.jdbc;</span><br><span class="line"></span><br><span class="line">import cn.itcase.student.student;</span><br><span class="line">import cn.itcase.util.JDBCutils;</span><br><span class="line"></span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class JDBC练习6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        JDBC练习6 jdbc练习6 &#x3D; new JDBC练习6();</span><br><span class="line">        List&lt;student&gt; list &#x3D; jdbc练习6.findAll();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;student&gt; findAll() &#123;</span><br><span class="line">        Statement stmt &#x3D;null;</span><br><span class="line">        ResultSet r&#x3D;null;</span><br><span class="line">        Connection connection &#x3D;null;</span><br><span class="line">        List&lt;student&gt; list&#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.注册驱动</span><br><span class="line">            &#x2F;&#x2F;3.定义sql</span><br><span class="line">            connection &#x3D; JDBCutils.getConnection();</span><br><span class="line">            String sql &#x3D; &quot;select * from student&quot;;</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql的对象</span><br><span class="line">            stmt &#x3D; connection.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            r &#x3D; stmt.executeQuery(sql);</span><br><span class="line">            &#x2F;&#x2F;6.遍历结果集，封装对象，装载集合</span><br><span class="line">            student student &#x3D; new student();</span><br><span class="line">            list &#x3D; new ArrayList&lt;student&gt;();</span><br><span class="line">            while (r.next()) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取数据</span><br><span class="line">                int id &#x3D; r.getInt(1);</span><br><span class="line">                String name &#x3D; r.getString(2);</span><br><span class="line">                String sex &#x3D; r.getString(3);</span><br><span class="line">                int age &#x3D; r.getInt(4);</span><br><span class="line">                String address &#x3D; r.getString(5);</span><br><span class="line">                &#x2F;&#x2F;创建对象,并赋值</span><br><span class="line">                student.setId(id);</span><br><span class="line">                student.setName(name);</span><br><span class="line">                student.setSex(sex);</span><br><span class="line">                student.setAge(age);</span><br><span class="line">                student.setAddress(address);</span><br><span class="line">                &#x2F;&#x2F;装载集合return list;</span><br><span class="line">                list.add(student);</span><br><span class="line">                return list;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        JDBCutils.close(r,stmt,connection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Student</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcase.student;</span><br><span class="line"></span><br><span class="line">public class student &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private int age;</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;student&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public student(int id, String name, String sex, int age, String address) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>毛概复习</title>
    <url>/post/6522.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="毛概复习重点"><a href="#毛概复习重点" class="headerlink" title="毛概复习重点"></a>毛概复习重点</h1><a id="more"></a>

<h2 id="一：选择题"><a href="#一：选择题" class="headerlink" title="一：选择题"></a>一：选择题</h2><h2 id="单选题："><a href="#单选题：" class="headerlink" title="单选题："></a>单选题：</h2><h2 id="1-近代中国的社会性质和中国革命的历史任务，决定了中国革命的性质是？"><a href="#1-近代中国的社会性质和中国革命的历史任务，决定了中国革命的性质是？" class="headerlink" title="1.近代中国的社会性质和中国革命的历史任务，决定了中国革命的性质是？"></a>1.近代中国的社会性质和中国革命的历史任务，决定了中国革命的性质是？</h2><p>资产阶级民主主义革命</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213503.jpg" alt="img"></p>
<h2 id="5-中国特色社会主义理论体系的最新成果是？"><a href="#5-中国特色社会主义理论体系的最新成果是？" class="headerlink" title="5.中国特色社会主义理论体系的最新成果是？"></a>5.中国特色社会主义理论体系的最新成果是？</h2><p>习近平新时代中国特色社会主义思想。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213522.jpg" alt="img"> </p>
<h2 id="6-新民主主义社会经济成分中，具有完全的社会主义性质的是？"><a href="#6-新民主主义社会经济成分中，具有完全的社会主义性质的是？" class="headerlink" title="6.新民主主义社会经济成分中，具有完全的社会主义性质的是？"></a>6.新民主主义社会经济成分中，具有完全的社会主义性质的是？</h2><p>国营经济</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213528.jpg" alt="img"></p>
<h2 id="8-当今时代的主题是？"><a href="#8-当今时代的主题是？" class="headerlink" title="8.当今时代的主题是？"></a>8.当今时代的主题是？</h2><p>和平与发展。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213531.jpg" alt="img"></p>
<h2 id="9-我们今天讲一切从实际出发，中国最大的实际就是？"><a href="#9-我们今天讲一切从实际出发，中国最大的实际就是？" class="headerlink" title="9.我们今天讲一切从实际出发，中国最大的实际就是？"></a>9.我们今天讲一切从实际出发，中国最大的实际就是？</h2><p>中国目前正处于并将长期处于社会主义初级阶段。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213535.jpg" alt="img"></p>
<h2 id="10-实现祖国和平统一的基础和前提是？"><a href="#10-实现祖国和平统一的基础和前提是？" class="headerlink" title="10.实现祖国和平统一的基础和前提是？"></a>10.实现祖国和平统一的基础和前提是？</h2><p>坚持一个中国原则。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213446.jpg" alt="img"></p>
<h2 id="11-党的十八大以来，我国在外交工作方面要构建新型国际关系的核心是？"><a href="#11-党的十八大以来，我国在外交工作方面要构建新型国际关系的核心是？" class="headerlink" title="11.党的十八大以来，我国在外交工作方面要构建新型国际关系的核心是？"></a>11.党的十八大以来，我国在外交工作方面要构建新型国际关系的核心是？</h2><p>合作共赢。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213447.jpg" alt="img"></p>
<h2 id="12-什么是“一化三改”"><a href="#12-什么是“一化三改”" class="headerlink" title="12.什么是“一化三改”"></a>12.什么是“一化三改”</h2><p>“一化”指的是逐步实现国家的社会主义工业化;“三改”指的是逐步实现国家对农业、手工业、资本主义工商业的社会主义改造。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816214726.png" alt="image-20200816214726126"></p>
<h2 id="13-我国“两个一百年”奋斗目标是？"><a href="#13-我国“两个一百年”奋斗目标是？" class="headerlink" title="13.我国“两个一百年”奋斗目标是？"></a>13.我国“两个一百年”奋斗目标是？</h2><p>第一个一百年，是到中国共产党成立100年时全面建成小康社会；</p>
<p>第二个一百年，是到新中国成立100年时建成富强民主文明和谐美丽的社会主义现代化强国。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816214825.png" alt="image-20200816214825887"></p>
<h2 id="17-社会主义的本质是什么？中国特色社会主义最本质的特征是？"><a href="#17-社会主义的本质是什么？中国特色社会主义最本质的特征是？" class="headerlink" title="17.社会主义的本质是什么？中国特色社会主义最本质的特征是？"></a>17.社会主义的本质是什么？中国特色社会主义最本质的特征是？</h2><p>本质：解放生产力、发展生产力。消灭剥削、消除两极分化、最终达到共同富裕。</p>
<p> 特征：中国共产党的领导。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816215751.png" alt="image-20200816215751692"></p>
<h2 id="19-中国特色社会主义建设的总体布局是什么？"><a href="#19-中国特色社会主义建设的总体布局是什么？" class="headerlink" title="19.中国特色社会主义建设的总体布局是什么？"></a>19.中国特色社会主义建设的总体布局是什么？</h2><p>经济建设、政治建设、文化建设、社会建设、生态文明建设“五位一体”。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222229.png" alt="image-20200816222229387"></p>
<h2 id="20-四个全面战略布局是什么？"><a href="#20-四个全面战略布局是什么？" class="headerlink" title="20.四个全面战略布局是什么？"></a>20.四个全面战略布局是什么？</h2><p>全面建成小康社会、全面深化改革、全面依法治国、全面从严治党。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222312.png" alt="image-20200816222312883"></p>
<h2 id="21-新民主主义革命理论的核心问题是？"><a href="#21-新民主主义革命理论的核心问题是？" class="headerlink" title="21.新民主主义革命理论的核心问题是？"></a>21.新民主主义革命理论的核心问题是？</h2><p>无产阶级的领导权。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222423.png" alt="image-20200816222423761"></p>
<h2 id="22-毛泽东在《论十大关系》中论述的第一大关系是？"><a href="#22-毛泽东在《论十大关系》中论述的第一大关系是？" class="headerlink" title="22.毛泽东在《论十大关系》中论述的第一大关系是？"></a>22.毛泽东在《论十大关系》中论述的第一大关系是？</h2><p>重工业和轻工业、农业的关系。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222436.png" alt="image-20200816222436618"></p>
<h2 id="24-邓小平指出：“贫穷不是社会主义，社会主义要消灭贫穷。”这个判断明确了？"><a href="#24-邓小平指出：“贫穷不是社会主义，社会主义要消灭贫穷。”这个判断明确了？" class="headerlink" title="24.邓小平指出：“贫穷不是社会主义，社会主义要消灭贫穷。”这个判断明确了？"></a>24.邓小平指出：“贫穷不是社会主义，社会主义要消灭贫穷。”这个判断明确了？</h2><p>社会主义本质的要求。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222515.png" alt="image-20200816222515786"></p>
<h2 id="25-加强党的建设应该放在首位的是？"><a href="#25-加强党的建设应该放在首位的是？" class="headerlink" title="25.加强党的建设应该放在首位的是？"></a>25.加强党的建设应该放在首位的是？</h2><p>思想建设。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222533.png" alt="image-20200816222533107"></p>
<h2 id="26-我国对外开放的基本立足点是？"><a href="#26-我国对外开放的基本立足点是？" class="headerlink" title="26.我国对外开放的基本立足点是？"></a>26.我国对外开放的基本立足点是？</h2><p>独立自主、自力更生。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222552.png" alt="image-20200816222552404"></p>
<h2 id="27-当前我国经济已经由高速增长阶段转向怎样的增长阶段？"><a href="#27-当前我国经济已经由高速增长阶段转向怎样的增长阶段？" class="headerlink" title="27.当前我国经济已经由高速增长阶段转向怎样的增长阶段？"></a>27.当前我国经济已经由高速增长阶段转向怎样的增长阶段？</h2><p>高质量发展。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222614.png" alt="image-20200816222614260"></p>
<h2 id="28-当今时代的主题是？"><a href="#28-当今时代的主题是？" class="headerlink" title="28.当今时代的主题是？"></a>28.当今时代的主题是？</h2><p>和平与发展。</p>
<h2 id="29-引领发展的第一动力，建设现代化经济体系的战略支撑是？"><a href="#29-引领发展的第一动力，建设现代化经济体系的战略支撑是？" class="headerlink" title="29.引领发展的第一动力，建设现代化经济体系的战略支撑是？"></a>29.引领发展的第一动力，建设现代化经济体系的战略支撑是？</h2><p>创新。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222629.png" alt="image-20200816222629450"></p>
<h2 id="30-一个国家、一个民族发展中更基本、更深沉、更持久的力量是？"><a href="#30-一个国家、一个民族发展中更基本、更深沉、更持久的力量是？" class="headerlink" title="30.一个国家、一个民族发展中更基本、更深沉、更持久的力量是？"></a>30.一个国家、一个民族发展中更基本、更深沉、更持久的力量是？</h2><p>文化自信。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222644.png" alt="image-20200816222644130"></p>
<h2 id="34-社会主义核心价值观中，国家层面的价值追求是？"><a href="#34-社会主义核心价值观中，国家层面的价值追求是？" class="headerlink" title="34.社会主义核心价值观中，国家层面的价值追求是？"></a>34.社会主义核心价值观中，国家层面的价值追求是？</h2><p>富强、民主、文明、和谐。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222736.png" alt="image-20200816222736019"></p>
<h2 id="38-近代中国革命的首要对象是？"><a href="#38-近代中国革命的首要对象是？" class="headerlink" title="38.近代中国革命的首要对象是？"></a>38.近代中国革命的首要对象是？</h2><p>帝国主义。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222902.png" alt="image-20200816222902570"></p>
<h2 id="39-标志着党探索中国社会主义建设道路的良好开端是？"><a href="#39-标志着党探索中国社会主义建设道路的良好开端是？" class="headerlink" title="39.标志着党探索中国社会主义建设道路的良好开端是？"></a>39.标志着党探索中国社会主义建设道路的良好开端是？</h2><p>《论十大关系》<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222917.png" alt="image-20200816222917052"></p>
<h2 id="41-生态文明的核心是？"><a href="#41-生态文明的核心是？" class="headerlink" title="41.生态文明的核心是？"></a>41.生态文明的核心是？</h2><p>统筹人与自然的和谐发展建设生态文明要遵循可持续发展的原则</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155637.png" alt="image-20200817155425340"></p>
<h2 id="42-中国特色社会主义理论体系的开篇之作是？"><a href="#42-中国特色社会主义理论体系的开篇之作是？" class="headerlink" title="42.中国特色社会主义理论体系的开篇之作是？"></a>42.中国特色社会主义理论体系的开篇之作是？</h2><p>邓小平理论。<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160026.png" alt="image-20200817160026311"></p>
<h2 id="44-科学发展观的科学内涵是什么？第一要义是？"><a href="#44-科学发展观的科学内涵是什么？第一要义是？" class="headerlink" title="44.科学发展观的科学内涵是什么？第一要义是？"></a>44.科学发展观的科学内涵是什么？第一要义是？</h2><p>内涵：科学发展观。 第一要义：发展。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155838.png" alt="image-20200817155838712"></p>
<h2 id="55-社会主义核心价值观中，社会层面的价值追求是指？"><a href="#55-社会主义核心价值观中，社会层面的价值追求是指？" class="headerlink" title="55.社会主义核心价值观中，社会层面的价值追求是指？"></a><strong>55.社会主义核心价值观中，社会层面的价值追求是指？</strong></h2><p>自由、平等、公正、法制</p>
<h2 id="46-人民军队完全区别于一切旧军队的政治特质和根本优势是？"><a href="#46-人民军队完全区别于一切旧军队的政治特质和根本优势是？" class="headerlink" title="46.人民军队完全区别于一切旧军队的政治特质和根本优势是？"></a>46.人民军队完全区别于一切旧军队的政治特质和根本优势是？</h2><p>党对军队绝对领导的根本原则和制度，发端于南昌起义，奠基于三湾改编，定型于古田会议，是人民军队完全区别于一切旧军队的政治特质和根本优势。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155707.png" alt="image-20200817155707767"></p>
<h2 id="49-全面建成小康社会的决胜期是？"><a href="#49-全面建成小康社会的决胜期是？" class="headerlink" title="49.全面建成小康社会的决胜期是？"></a>49.全面建成小康社会的决胜期是？</h2><p>2020年<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155654.png" alt="image-20200817155654441"></p>
<h2 id="50-社会主义基本制度在中国初步确立的标志是？"><a href="#50-社会主义基本制度在中国初步确立的标志是？" class="headerlink" title="50.社会主义基本制度在中国初步确立的标志是？"></a>50.社会主义基本制度在中国初步确立的标志是？</h2><p>1956年完成对农业、手工业和资本主义商业的社会主义改造</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155902.png" alt="image-20200817155902103"></p>
<h2 id="51-邓小平理论回答的首要的基本的理论问题是？"><a href="#51-邓小平理论回答的首要的基本的理论问题是？" class="headerlink" title="51.邓小平理论回答的首要的基本的理论问题是？"></a>51.邓小平理论回答的首要的基本的理论问题是？</h2><p>什么是社会主义，怎样建设社会主义？</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161120.png" alt="image-20200817161120886"></p>
<h2 id="52-党的十八大提出，我国将在哪一年实现全面建成小康社会的奋斗目标？"><a href="#52-党的十八大提出，我国将在哪一年实现全面建成小康社会的奋斗目标？" class="headerlink" title="52.党的十八大提出，我国将在哪一年实现全面建成小康社会的奋斗目标？"></a>52.党的十八大提出，我国将在哪一年实现全面建成小康社会的奋斗目标？</h2><p>2020年 </p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161145.png" alt="image-20200817161145351"></p>
<h2 id="53-2018版的新教材充分反映马克思主义中国化各个理论成果的主要内容，突出了什么样的理论逻辑和历史逻辑？"><a href="#53-2018版的新教材充分反映马克思主义中国化各个理论成果的主要内容，突出了什么样的理论逻辑和历史逻辑？" class="headerlink" title="53.2018版的新教材充分反映马克思主义中国化各个理论成果的主要内容，突出了什么样的理论逻辑和历史逻辑？"></a><strong>53.2018版的新教材充分反映马克思主义中国化各个理论成果的主要内容，突出了什么样的理论逻辑和历史逻辑？</strong></h2><p> <img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161830.png" alt="image-20200817161829979"></p>
<h2 id="57-中国新时期的强军目标是建设一支什么样的人民军队？"><a href="#57-中国新时期的强军目标是建设一支什么样的人民军队？" class="headerlink" title="57.中国新时期的强军目标是建设一支什么样的人民军队？"></a><strong>57.中国新时期的强军目标是建设一支什么样的人民军队？</strong></h2><p>听党指挥、能打胜仗、作风优良的人民军队</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161558.png" alt="image-20200817161558166"></p>
<h2 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h2><h2 id="2-马克思主义中国化形成的两大理论成果是？"><a href="#2-马克思主义中国化形成的两大理论成果是？" class="headerlink" title="2.马克思主义中国化形成的两大理论成果是？"></a>2.马克思主义中国化形成的两大理论成果是？</h2><p>毛泽东思想和中国特色社会主义理论体系。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213507.jpg" alt="img"></p>
<h2 id="7-新民主主义革命的三大法宝是？新民主主义革命的动力包括？"><a href="#7-新民主主义革命的三大法宝是？新民主主义革命的动力包括？" class="headerlink" title="7.新民主主义革命的三大法宝是？新民主主义革命的动力包括？"></a>7.新民主主义革命的三大法宝是？新民主主义革命的动力包括？</h2><h3 id="90-多选题"><a href="#90-多选题" class="headerlink" title="90%多选题"></a>90%多选题</h3><p>统一战线，武装斗争，党的建设</p>
<p>工人阶级、农民阶级、城市小资产阶级和民族资产阶级。</p>
<h2 id="14-什么是四个自信？"><a href="#14-什么是四个自信？" class="headerlink" title="14.什么是四个自信？"></a>14.什么是四个自信？</h2><p>道路自信、理论自信、制度自信、文化自信</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816215550.png" alt="image-20200816215550846"></p>
<h2 id="15-什么是和平赎买？"><a href="#15-什么是和平赎买？" class="headerlink" title="15.什么是和平赎买？"></a>15.什么是和平赎买？</h2><p>对资产阶级的生产资料通过和平方式并采取有偿办法实行国有化，在一定年限内让资本家从企业经营所得中获得一部分利润的政策。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816215700.png" alt="image-20200816215700425"></p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816215715.png" alt="image-20200816215715509"></p>
<h2 id="16-什么是一国两制"><a href="#16-什么是一国两制" class="headerlink" title="16.什么是一国两制?"></a>16.什么是一国两制?</h2><p>指在一个中国的前提下，国家的主体坚持社会主义制度，香港、澳门、台湾保持原有的资本主义制度长期不变。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816215731.png" alt="image-20200816215731485"></p>
<h2 id="31-什么是四项基本原则？"><a href="#31-什么是四项基本原则？" class="headerlink" title="31.什么是四项基本原则？"></a>31.什么是四项基本原则？</h2><p>即坚持社会主义道路，坚持无产阶级专政（人民民主专政），坚持共产党的领导，坚持马列主义、毛泽东思想。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817162401.png" alt="image-20200817162401870"></p>
<h2 id="32-过渡时期的“一体两翼”是指？"><a href="#32-过渡时期的“一体两翼”是指？" class="headerlink" title="32.过渡时期的“一体两翼”是指？"></a>32.过渡时期的“一体两翼”是指？</h2><p>“一化”即逐步实现国家社会主义工业化,就是要进行社会主义改造,这是主体;</p>
<p>“三改”即逐步实现国家对农业、手工业和资本主义工商业的社会主义改造,这是“两翼”</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222703.png" alt="image-20200816222703538"></p>
<h2 id="33-习近平总书记指出，实现中国梦，必须走什么路？弘扬和凝聚？"><a href="#33-习近平总书记指出，实现中国梦，必须走什么路？弘扬和凝聚？" class="headerlink" title="33.习近平总书记指出，实现中国梦，必须走什么路？弘扬和凝聚？"></a>33.习近平总书记指出，实现中国梦，必须走什么路？弘扬和凝聚？</h2><p>走中国道路，弘扬中国精神，凝聚中国力量。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222724.png" alt="image-20200816222724130"></p>
<h2 id="35-党的十九大提出，要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循的原则是？"><a href="#35-党的十九大提出，要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循的原则是？" class="headerlink" title="35.党的十九大提出，要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循的原则是？"></a>35.党的十九大提出，要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循的原则是？</h2><p>共商共建共享。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222751.png" alt="image-20200816222751329"></p>
<h2 id="37-巩固和发展爱国统一战线，中国共产党同各民主党派进行合作的方针是？"><a href="#37-巩固和发展爱国统一战线，中国共产党同各民主党派进行合作的方针是？" class="headerlink" title="37.巩固和发展爱国统一战线，中国共产党同各民主党派进行合作的方针是？"></a>37.巩固和发展爱国统一战线，中国共产党同各民主党派进行合作的方针是？</h2><p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222834.png" alt="image-20200816222834323"></p>
<p>长期共存、互相监督、肝胆相照、荣辱与共。</p>
<h2 id="40-在各个领域和方面都要突出总揽全局、协调各方的领导核心地位的是？"><a href="#40-在各个领域和方面都要突出总揽全局、协调各方的领导核心地位的是？" class="headerlink" title="40.在各个领域和方面都要突出总揽全局、协调各方的领导核心地位的是？"></a>40.在各个领域和方面都要突出总揽全局、协调各方的领导核心地位的是？</h2><p>党的领导<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222957.png" alt="image-20200816222957452"></p>
<h2 id="47-我国社会主义初级阶段的主要矛盾是生产力和生产关系的矛盾？"><a href="#47-我国社会主义初级阶段的主要矛盾是生产力和生产关系的矛盾？" class="headerlink" title="47.我国社会主义初级阶段的主要矛盾是生产力和生产关系的矛盾？"></a>47.我国社会主义初级阶段的主要矛盾是生产力和生产关系的矛盾？</h2><p>不是。是人民日益增长的物质文化需要同落后的社会生产之间的矛盾</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155728.png" alt="image-20200817155728227"></p>
<h2 id="48-从1949年建国到今天，我国不同时期的主要矛盾及根本任务是什么？"><a href="#48-从1949年建国到今天，我国不同时期的主要矛盾及根本任务是什么？" class="headerlink" title="48.从1949年建国到今天，我国不同时期的主要矛盾及根本任务是什么？"></a>48.从1949年建国到今天，我国不同时期的主要矛盾及根本任务是什么？</h2><p>社会主义初级阶段：主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。根本任务：集中力量发展生产力。<br>中国新时代阶段：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。 根本任务：调整经济结构。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155801.png" alt="image-20200817155801424"></p>
<h2 id="58-走中国特色社会主义政治发展道路，必须坚持哪三者有机统一？"><a href="#58-走中国特色社会主义政治发展道路，必须坚持哪三者有机统一？" class="headerlink" title="58.走中国特色社会主义政治发展道路，必须坚持哪三者有机统一？"></a><strong>58.走中国特色社会主义政治发展道路，必须坚持哪三者有机统一？</strong></h2><p>党的领导、人民当家作主、依法治国</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161718.png" alt="image-20200817161718061"></p>
<h2 id="59-构建人类命运共同体思想的核心是建设什么样的世界？"><a href="#59-构建人类命运共同体思想的核心是建设什么样的世界？" class="headerlink" title="59.构建人类命运共同体思想的核心是建设什么样的世界？"></a>59.构建人类命运共同体思想的核心是建设什么样的世界？</h2><p>持久和平、普遍安全、共同繁荣、开放包容、清洁美丽</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161651.png" alt="image-20200817161651142"></p>
<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="简答大题：3-毛泽东思想形成和发展的社会历史条件是什么？"><a href="#简答大题：3-毛泽东思想形成和发展的社会历史条件是什么？" class="headerlink" title="简答大题：3.毛泽东思想形成和发展的社会历史条件是什么？"></a>简答大题：3.毛泽东思想形成和发展的社会历史条件是什么？</h2><p>第一，20世纪前中期世界和中国政局的变动，是毛泽东思想产生和形成的时代背景。</p>
<p>第二，近现代中国社会和革命运动的发展，是毛泽东思想产生和形成的客观需要。</p>
<p>第三，新的社会生产力的增长和工人运动的发展，是毛泽东思想产生和形成的物质基础。</p>
<p>第四，新文化运动的兴起和马克思列宁主义的传入与传播，是毛泽东思想产生和形成的思想理论条件。</p>
<p>第五，中国共产党领导的人民革命，是毛泽东思想产生和形成的实践基础</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213514.jpg" alt="img"></p>
<h2 id="大题：4-毛泽东思想的主要内容包括-毛泽东思想活的灵魂是？"><a href="#大题：4-毛泽东思想的主要内容包括-毛泽东思想活的灵魂是？" class="headerlink" title="大题：4.毛泽东思想的主要内容包括?毛泽东思想活的灵魂是？"></a>大题：4.毛泽东思想的主要内容包括?毛泽东思想活的灵魂是？</h2><p><strong>主要内容</strong>：</p>
<p>（1） 新民主主义革命理论。是反映新民主主义革命客观规律的完备的理论形态。</p>
<p>（2） 社会主义革命和社会主义建设理论。毛泽东在新民主主义革命胜利和社会主义制度建立后，分别提出了诸多正确的思想主张，对中国特色社会主义建设道理的探索具有重要的指导意义。</p>
<p>（3） 革命军队建设和军事战略的理论。系统地解决了如何把以农民为主要成分的革命军队建设成一支无产阶级性质的、具有严格纪律的、同人民群众保持亲密联系的新型人民军队的问题。</p>
<p>（4） 政策和策略的理论。毛泽东精辟地论证了革命斗争中政策和策略问题的极端重要性，指出政策和策略是党的生命，必须根据政治形势、阶级关系和实际情况及其变化制定党的政策，把原则性和灵活性结合起来。</p>
<p>（5） 思想政治工作和文化工作的理论。毛泽东根据“一定的文化是一定社会的政治和经济的反映，又给予伟大影响和作用于一定社会的政治和经济，而经济是基础，政治则是经济的集中的表现”这个基本观点，提出了许多具有长远意义的重要思想。</p>
<p>（6） 党的建设理论。党的三大优良作风是：理论与实践相结合的作风，和人民群众紧密地联系在一起的作风，自我批评的作风。两个务必是：务必继续保持谦虚、谨慎、不骄、不躁的作风，务必继续保持艰苦奋斗的作风。</p>
<p><strong>活的灵魂：</strong></p>
<p>（1） 实事求是。就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。这是毛泽东思想的<strong>精髓。</strong></p>
<p>（2） 群众路线。就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。这是中国共产党的<strong>根本路线</strong>。</p>
<p>（3） 独立自主。就是坚持独立思考，走自己的路，坚定不移地维护民族独立，捍卫国家主权，把立足点放在依靠自己的力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。这是中国共产党进行革命与建设的<strong>基本立足点</strong>。</p>
<p>90%大题</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816213519.jpg" alt="img"></p>
<h2 id="18-三个代表”重要思想的核心观点是什么？"><a href="#18-三个代表”重要思想的核心观点是什么？" class="headerlink" title="18.三个代表”重要思想的核心观点是什么？"></a>18.三个代表”重要思想的核心观点是什么？</h2><p>中国共产党必须始终代表中国先进生产力的发展要求</p>
<p>中国共产党必须始终代表中国先进文化的前进方向</p>
<p>中国共产党必须始终代表中国最广大人民的根本利益</p>
<p>（1）始终代表中国先进生产力的发展要求。</p>
<p>A. 社会主义的根本任务是发展社会生产力，马克思主义执政党必须高度重视解放和发展生产力。始终代表中国先进生产力的发展要求，大力促进先进生产力的发展，是我们党站在时代前列，保持先进性的根本体现和根本要求。</p>
<p>B.广大工人、农民和知识分子始终是推动我国先进生产力发展和社会全面进步的根本力量。</p>
<p>C.人是生产力中最活跃的因素。</p>
<p>D.科学技术是第一生产力，是先进生产力的集中体现和主要标志。科技进步和创新式发展生产力的决定因素。</p>
<p>E.科学的本质是创新，只有大力推进知识创新、科技创新、才能实现技术的跨越式发展。</p>
<p>（2）始终代表中国先进文化的前进方向。</p>
<p>A.发展社会主义先进文化，就是建设社会主义精神文明。</p>
<p>B.发展社会主义先进文化，就是发展面向现代化、面向世界、面向未来的、民族的科学的大众的社会主义文化。</p>
<p>C.发展社会主义先进文化，必须弘扬民族精神。</p>
<p>D,发展社会主义先进文化，必须加强社会主义思想道德建设，这是发展先进文化的重要内容和中心环节。</p>
<p>E.发展社会主义先进文化，必须做好思想政治工作。思想政治工作是经济工作和其他一切工作的生命线。</p>
<p>（3）始终代表中国最广大人民的根本利益。</p>
<p>人民是我们国家的主人，是决定我国前途和命运的根本力量，是历史的真正创造者。我们全部工作的出发点和落脚点，就是不断实现好维护好发展好最广大人民的根本利益。</p>
<p>A. 我们党来自于人民，植根于人民。服务于人民。党的全部任务和责任，就是为实现人民群众的根本利益而奋斗。</p>
<p>B. 我们党始终坚持人民的利益高于一切。党的一切工作，必须以最广大人民的根本利益为最高标准。</p>
<p>10%选择题： <img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816220810.png" alt="image-20200816220810901">90%大题</p>
<h2 id="36-如何建设“一带一路”？"><a href="#36-如何建设“一带一路”？" class="headerlink" title="36.如何建设“一带一路”？"></a>36.如何建设“一带一路”？</h2><p>政策沟通：沿线各国可以就经济发展战略和对策进行充分交流对接，共同制定推进区域合作的规划和措施。</p>
<p>资金融通：扩大沿线国家双边本币互换、结算的范围和规模；共同推进亚洲基础设施投资银行、金砖国家开发银行筹建，有关各方就建立上海合作组织融资机构开展磋商。</p>
<p>设施联通：交通方面，优先打通缺失路段，畅通瓶颈路段，提升道路通达水平；能源方面，推进跨境电力与输电通道建设，积极开展区域电网升级改造合作。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222816.png" alt="image-20200816222816475"></p>
<h2 id="23-十九大的主题是？"><a href="#23-十九大的主题是？" class="headerlink" title="23.十九大的主题是？"></a>23.十九大的主题是？</h2><p>不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200816222459.png" alt="image-20200816222459474"></p>
<h2 id="43-新民主主义社会是一个独立的社会形态吗？"><a href="#43-新民主主义社会是一个独立的社会形态吗？" class="headerlink" title="43.新民主主义社会是一个独立的社会形态吗？"></a>43.新民主主义社会是一个独立的社会形态吗？</h2><p>不是<img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155930.png" alt="image-20200817155930305"></p>
<h2 id="45-如何理解习近平强军思想的主要内容？"><a href="#45-如何理解习近平强军思想的主要内容？" class="headerlink" title="45.如何理解习近平强军思想的主要内容？"></a>45.如何理解习近平强军思想的主要内容？</h2><p>习近平的强军思想作为一个科学的理论体系，它实际上是深刻回答了在我们国家由大向强、逐步走向世界舞台中央这样一个时代进程中，我们人民军队听谁指挥、怎样筑牢军魂、为什么要强军、怎么强军、打什么仗、怎样打胜仗这样一些基本问题重大问题，它丰富和发展了我们党建军、治军的一些指导思想、方针原则，也就是它引领着我们人民军队走上了强军的新征程。</p>
<p>一是强国必须强军,巩固国防和强大人民军队是新时代坚持和发展中国特色社会主义,实现“两个一百年”奋斗目标、实现中华民族伟大复兴的战略支撑,必须努力建设与我国国际地位相称、与国家安全和发展利益相适应的巩固国防和强大军队。二是党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队,必须同国家现代化进程相一致,全面建设世界一流军队。三是党对军队的绝对领导是人民军队建军之本、强军之魂,必须全面贯彻党领导军队的一系列根本原则和制度,确保部队绝对忠诚、绝对纯洁、绝对可靠。四是军队是要准备打仗的,必须聚焦能打仗、打胜仗,创新发展军事战略指导,构建中国特色现代作战体系,全面提高新时代备战打仗能力,有效塑造态势、管控危机、遏制战争、打赢战争。五是作风优良是我军鲜明特色和政治优势,必须加强作风建设、纪律建设,坚定不移正风肃纪、反腐惩恶,大力弘扬我党我军光荣传统和优良作风,永葆人民军队性质、宗旨、本色。六是推进强军事业必须坚持政治建军、改革强军、科技兴军、依法治军,更加注重聚焦实战、更加注重创新驱动、更加注重体系建设、更加注重集约高效、更加注重军民融合,全面提高革命化现代化正规化水平。七是改革是强军的必由之路,必须推进军队组织形态现代化,构建中国特色现代军事力量体系,完善中国特色社会主义军事制度。八是创新是引领发展的第一动力,必须坚持向科技创新要战斗力,统筹推进军事理论、技术、组织、管理、文化等各方面创新,建设创新型人民军队。九是现代化军队必须构建中国特色军事法治体系,推进治军方式根本性变革,提高国防和军队建设法治化水平。十是军民融合发展是兴国之举、强军之策,必须坚持发展和安全兼顾、富国和强军统一,形成全要素、多领域、高效益军民融合深度发展格局,构建一体化的国家战略体系和能力。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817155628.png" alt="image-20200817155442914"></p>
<h2 id="54-在1992年南方谈话中，邓小平明确地提出了“三个有利于”标准，它的具体内容是？"><a href="#54-在1992年南方谈话中，邓小平明确地提出了“三个有利于”标准，它的具体内容是？" class="headerlink" title="54.在1992年南方谈话中，邓小平明确地提出了“三个有利于”标准，它的具体内容是？"></a><strong>54.在1992年南方谈话中，邓小平明确地提出了“三个有利于”标准，它的具体内容是？</strong></h2><p>是否有利于发展社会主义社会的生产力、是否有利于增强社会主义国家的综合国力、是否有利于提高人民的生活水平。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161208.png" alt="image-20200817161208256"></p>
<h2 id="56-当前中国讲文化自信，其含义是？"><a href="#56-当前中国讲文化自信，其含义是？" class="headerlink" title="56.当前中国讲文化自信，其含义是？"></a><strong>56.当前中国讲文化自信，其含义是？</strong></h2><p>一是对马克思主义文化的自信，二是对中国优秀传统文化的自信。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161453.png" alt="image-20200817161453522"></p>
<h2 id="60-新民主主义基本纲领的主要内容是什么？"><a href="#60-新民主主义基本纲领的主要内容是什么？" class="headerlink" title="60.新民主主义基本纲领的主要内容是什么？"></a><strong>60.新民主主义基本纲领的主要内容是什么？</strong></h2><p>包括新民主主义的政治纲领、新民主主义的经济纲领和新民主主义的文化纲领。新民主主义的政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。新民主主义的经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。新民主主义的文化纲领：无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161617.png" alt="image-20200817161617254"></p>
<h2 id="61-中国确立社会主义基本制度的重大意义是什么？"><a href="#61-中国确立社会主义基本制度的重大意义是什么？" class="headerlink" title="61.中国确立社会主义基本制度的重大意义是什么？"></a><strong>61.中国确立社会主义基本制度的重大意义是什么？</strong></h2><p>社会主义基本制度的确立是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提。</p>
<p>（1） 社会主义基本制度的确立，极大地提高了工人阶级和广大劳动人民的积极性、创造性，极大地促进了我国社会生产力的发展。</p>
<p>（2） 社会主义基本制度的确立，使广大劳动人民真正成为国家的主人。极大地巩固和扩大了工人阶级领导的、以工农联盟为基础的人民民主专政国家政权的阶级基础和经济基础。</p>
<p>（3） 社会主义基本制度的确立，使中国进入了社会主义社会，是世界社会主义发展史上又一个历史性的伟大胜利。它进一步改变了世界政治经济格局，增强了社会主义力量，对维护世界和平产生了积极影响。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160836.png" alt="image-20200817160836481"></p>
<h2 id="62-如何认识邓小平理论形成的社会历史条件？"><a href="#62-如何认识邓小平理论形成的社会历史条件？" class="headerlink" title="62.如何认识邓小平理论形成的社会历史条件？"></a><strong>62.如何认识邓小平理论形成的社会历史条件？</strong></h2><p>（1）和平与发展成为时代主题是邓小平理论形成的时代背景。20世纪70年代，西方资本主义遭遇严重的经济危机，战后美苏两极对抗的冷战格局出现重大变化，长期被冷战阴云笼罩的世界各国人民对和平的渴望更加强烈，求和平谋发展逐渐成为世界各国人民的普遍愿望。邓小平敏锐地把握了国际形势的重大变化，对时代主题的转换做出了科学判断。</p>
<p>（2）社会主义建设的经验教训是邓小平理论形成的历史根据。新中国成立后，我们顺利地恢复了国民经济，走出了一条具有鲜明中国特色的社会主义改造道路，但也犯了不少错误。十一届三中全会以后，以邓小平为主要代表的中国共产党人，领导全党和全国人民，果断地纠正了这些错误，深刻地分析了它出现的原因，同时又坚决地维护和继承了过去在理论上和实践上所取得的一切积极成果。</p>
<p>（3）改革开放和现代化建设的实践是邓小平理论形成的现实依据。我国改革开放和社会主义现代化建设的崭新实践，是人民群众生机勃勃的伟大创造，是理论发展的源泉。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160852.png" alt="image-20200817160852840"></p>
<h2 id="63-如何认识中国特色社会主义进入新时代？"><a href="#63-如何认识中国特色社会主义进入新时代？" class="headerlink" title="63.如何认识中国特色社会主义进入新时代？"></a><strong>63.如何认识中国特色社会主义进入新时代？</strong></h2><p>（1）从中华民族复兴的进程来看，意味着历经磨难的中华民族实现了从站起来，富起来到强起来的伟大飞跃，迎来了中华民族伟大复兴的前景。</p>
<p>（2）从科学社会主义发展进程来看，意味着科学社会主义在21世纪的中国焕发了强大的生命活力，在世界上高高举起了中国特色社会主义的伟大旗帜。</p>
<p>（3）从人类文明进程来看，意味着中国特色社会主义道路、制度、理论、文化不断发展，拓宽了发展中国家进入社会主义新时代途径。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160918.png" alt="image-20200817160917864"></p>
<h2 id="64-如何把握新时代中国特色社会主义发展的战略安排？"><a href="#64-如何把握新时代中国特色社会主义发展的战略安排？" class="headerlink" title="64.如何把握新时代中国特色社会主义发展的战略安排？"></a><strong>64.如何把握新时代中国特色社会主义发展的战略安排？</strong></h2><p><strong>新时代中国特色社会主义发展的战略安排，顺应了我国社会生产力的发展趋势和要求；把握了我国社会主要矛盾的变化；提升了我国参与国际竞争的能力和信心。</strong></p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160942.png" alt="image-20200817160942575"></p>
<h2 id="65-如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一？"><a href="#65-如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一？" class="headerlink" title="65.如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一？"></a><strong>65.如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一？</strong></h2><p>1.中国共产党的领导是人民当家作主和依法治国的根本保证。在我国这样一个发展中大国,离开了共产党的领导,就不可能把全国人民的力量和意志凝聚起来,发展社会主义民主也就无从谈起。</p>
<p>2.人民当家作主是社会主义民主政治的本质要求,是社会主义政治文明建设的根本出发点和归宿。社会主义民主政治的本质是人民当家作主。</p>
<p>3.依法治国是党领导人民治理国家的基本方略。依法治国与人民民主、党的领导是紧密联系、相辅相成。依法治国不仅从制度上、法律上保证人民当家作主，而且也从制度上、法律上保证党的执政地位。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817160956.png" alt="image-20200817160956070"></p>
<h2 id="66-决胜全面建成小康社会提出来哪些新要求？"><a href="#66-决胜全面建成小康社会提出来哪些新要求？" class="headerlink" title="66.决胜全面建成小康社会提出来哪些新要求？"></a>66.决胜全面建成小康社会提出来哪些新要求？</h2><p>经济保持中高速增长、创新驱动成效显著、发展协调性明显增强、人民生活水平和质量普遍提高、国民素质和社会文明程度显著提高、生态环境质量总体改善、各方面制度更加成熟更加定型。</p>
<p><img src="https://gitee.com/studentliuchang/biogImg/raw/master/img/20200817161053.png" alt="image-20200817161053415"></p>
<h2 id="67。当前，我国生态文明建设面临哪些严峻形势？请你结合自身实际，论述当代大学生应当如何树立生态文明理念？"><a href="#67。当前，我国生态文明建设面临哪些严峻形势？请你结合自身实际，论述当代大学生应当如何树立生态文明理念？" class="headerlink" title="67。当前，我国生态文明建设面临哪些严峻形势？请你结合自身实际，论述当代大学生应当如何树立生态文明理念？"></a>67。当前，我国生态文明建设面临哪些严峻形势？请你结合自身实际，论述当代大学生应当如何树立生态文明理念？</h2><p><strong>严峻形势：资源约束趋紧、环境污染严重、生态系统退化等</strong></p>
<p><strong>一是要全面促进资源节约。要节约集约利用资源，推动资源利用方式根本转变，加强全过程节约管理，大幅降低能源、水、土地消耗强度，提高利用效率和效益。</strong></p>
<p><strong>二是要树立尊重自然、顺应自然、保护自然的生态文明理念，这是推进生态文明建设的重要思想基础，体现了新的价值取向和生态伦理。</strong></p>
<p><strong>三是要加大自然生态系统和环境保护力度，以解决损害群众健康最突出的环境问题为重点，强化污染防治力度，实施重大生态修复工程，增强生态产品生产能力。</strong></p>
<p><strong>四是要着力推进绿色发展、循环发展、低碳发展。</strong></p>
<p><strong>五是要应转变生活方式和消费方式，改变一些传统的不合理的生活方式，改变奢侈消费、劣质消费等习惯。</strong></p>
<h2 id="68-党的十八大以来，我们党明确提出了总体国家安全观。结合当前形势和个人理解，请问你认为应该如何全面贯彻落实总体国家安全观？"><a href="#68-党的十八大以来，我们党明确提出了总体国家安全观。结合当前形势和个人理解，请问你认为应该如何全面贯彻落实总体国家安全观？" class="headerlink" title="68.党的十八大以来，我们党明确提出了总体国家安全观。结合当前形势和个人理解，请问你认为应该如何全面贯彻落实总体国家安全观？"></a>68.党的十八大以来，我们党明确提出了总体国家安全观。结合当前形势和个人理解，请问你认为应该如何全面贯彻落实总体国家安全观？</h2><p>1.全面贯彻落实总体国家安全观，必须坚持统筹发展和安全两件大事，既要善于运用发展成果夯实国家安全的实力基础，又要善于塑造有利于经济社会发展的安全环境;必须坚持人民安全、政治安全、国家利益至上的有机统一。习近平总书记指出，人民安全是国家安全的宗旨，政治安全是国家安全的根本，国家利益至上是国家安全的准则。</p>
<p>2.全面贯彻落实总体国家安全观，就要坚持立足于防，又有效处置风险。凡事预则立，不预则废。“立足于防”是富有中国特色的国家安全智慧，要有效处置风险，就必须具有维护国家安全的能力和效率。</p>
<p>3.全面贯彻落实总体国家安全观，还必须坚持维护和塑造国家安全。塑造是更高层次更具前瞻性的维护，要发挥负责任大国作用，同世界各国一起，推动构建人类命运共同体。</p>
<p>4.全面贯彻落实总体国家安全观，更需要坚持科学统筹，始终把国家安全置于中国特色社会主义事业全局中来把握，充分调动各方面积极性，形成维护国家安全合力。</p>
<h2 id="69-作为一名新时代大学生，你如何理解“不忘初心、牢记使命”主题教育的重大意义？你自己又将如何做好不忘求学初心、勇担家国责任？。"><a href="#69-作为一名新时代大学生，你如何理解“不忘初心、牢记使命”主题教育的重大意义？你自己又将如何做好不忘求学初心、勇担家国责任？。" class="headerlink" title="69.作为一名新时代大学生，你如何理解“不忘初心、牢记使命”主题教育的重大意义？你自己又将如何做好不忘求学初心、勇担家国责任？。"></a>69.作为一名新时代大学生，你如何理解“不忘初心、牢记使命”主题教育的重大意义？你自己又将如何做好不忘求学初心、勇担家国责任？。</h2><p><strong>意义</strong></p>
<p><strong>1、</strong>用习近平新时代中国特色社会主义思想武装全党的迫切需要</p>
<p><strong>2</strong>、推进新时代党的建设的迫切需要</p>
<p><strong>3</strong>、是保持党同人民群众血肉联系的迫切需要</p>
<p><strong>4</strong>、是实现党的十九大确定的目标任务的迫切需要</p>
<p><strong>第二问：</strong></p>
<p>1、我们应该坚持用习近平新时代中国特色社会主义思想武装头脑、指导行动。</p>
<p>2、我们是新时代的建设者和生力军，要树立强烈的新时代主人翁意识和责任感，</p>
<p>3、理应紧跟党走在最前列，在应对各种重大和矛盾中发挥积极作用，勇敢担负起捍卫、开拓新时代的重任。</p>
<h2 id="70-谈谈你对社会主义核心价值观内容的理解，并结合实际谈谈作为当代大学生"><a href="#70-谈谈你对社会主义核心价值观内容的理解，并结合实际谈谈作为当代大学生" class="headerlink" title="70.谈谈你对社会主义核心价值观内容的理解，并结合实际谈谈作为当代大学生"></a>70.谈谈你对社会主义核心价值观内容的理解，并结合实际谈谈作为当代大学生</h2><p>一是坚持马克思主义的指导思想。我们要用马克思主义中国化的最新理论成果武装自己。</p>
<p>二是我们要树立中国特色社会主义共同理想,坚定中国特色社会主义理想信念。</p>
<p>三是我们要学习和弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神。</p>
<p>四是要以“八荣八耻”为主要内容的社会主义荣辱观作为我们道德实践的评判标准,引导我们明是非,知荣辱,辨善恶,分美丑。                                                                                                                        </p>
<p> <strong>—-转载自<a href="https://studentliuchang.gitee.io/">Student-Chang</a></strong></p>
]]></content>
      <tags>
        <tag>毛概复习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习</title>
    <url>/post/8df0ec14.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h1><a id="more"></a>

<h2 id="数学工具类Math"><a href="#数学工具类Math" class="headerlink" title="数学工具类Math"></a>数学工具类Math</h2><p>public static double abs(double num)；绝对值</p>
<p>public static double ceil(double num)；向上取整</p>
<p>public static double floor(double num)；向下取整</p>
<p>public static double round(double num)；四舍五入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(Math.abs(3.14));&#x2F;&#x2F;输出3.14</span><br><span class="line">System.out.println(Math.ceil(3.14));&#x2F;&#x2F;输出4.0</span><br><span class="line">System.out.println(Math.floor(3.14));&#x2F;&#x2F;输出3.0</span><br><span class="line">System.out.println(Math.round(3.14));&#x2F;&#x2F;输出3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>1.final修饰的类无法继承。</p>
<p>2.final修饰的方法无法覆盖。</p>
<p>3.final修饰的变量只能赋值一次。</p>
<p>4.final修饰的引用一旦指向某个对象， 则不能再重新指向其他对象，但该引用指向的对象内部的数据是可以修改的。</p>
<p>5.final修饰的实例变量必须手动初始化，不能采用系统默认值。</p>
<p>6.final修饰的实例变量一般和static联合使用，成为常量。</p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>1.抽象类定义：在class前添加abstract关键字就行。</p>
<p>2.抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。</p>
<p>3.final和abstract不能联合使用，这两个关键字是对立的。</p>
<p>4.抽象类的子类可以使抽象类，也可以是非抽象类。</p>
<p>5.抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。</p>
<p>6.抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</p>
<p>7.抽象方法怎么定义？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract void doSome();</span><br></pre></td></tr></table></figure>

<p>8.一个非抽象类，继承抽象类，必须将抽象类中的抽象方法覆盖（实现）。</p>
<ul>
<li><p>面试题（判断题）：Java语言中凡是没有方法体的方法都是抽象方法。</p>
<p>不对，错误的。</p>
<p>Object类种就有很多都没有方法体，都是以“；“结尾的，但是他们都不是抽象方法，例如：</p>
<p>public native int hashCode();</p>
<p>这个方法底层调用了C++写的动态链接库程序。</p>
<p>前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</p>
</li>
<li><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li>
</ul>
<p>1.接口是一种引用数据类型。编译之后也是一个class字节码文件。</p>
<p>2.借口是完全抽象。</p>
<p>3.接口怎么定义：[修饰符列表] interface 接口名{}</p>
<p>4.接口支持多继承。</p>
<p>5.接口中只包含常量+抽象方法。</p>
<p>6.接口中的所有元素都是public修饰的。（都是公开的。）</p>
<p>7.接口中的抽象方法定义时：public abstract修饰符可以省略。常量也是。</p>
<p>8.接口中的方法都是抽象方法，所以接口中的方法不能有方法体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义接口</span><br><span class="line">interface A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;接口支持继承</span><br><span class="line">interface B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;支持多继承</span><br><span class="line">interface C extends A,B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;我的数学方法</span><br><span class="line">interface MyMath&#123;</span><br><span class="line">	&#x2F;&#x2F;常量</span><br><span class="line">	public static final double PI &#x3D; 3.1415926;</span><br><span class="line">	&#x2F;&#x2F;也可以省略</span><br><span class="line">	double PI &#x3D; 3.1415926;&#x2F;&#x2F;PI是常量，不可变</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;抽象方法</span><br><span class="line">	public abstract int sum(int a , int b);</span><br><span class="line">	&#x2F;&#x2F;也可以省略</span><br><span class="line">	&#x2F;&#x2F;int sum(int a , int b);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;接口中的方法可以有方法体嘛？</span><br><span class="line">	&#x2F;&#x2F;错误：接口抽象方法不能带有主体</span><br><span class="line">	&#x2F;*</span><br><span class="line">	void doSome()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的基础语法：</p>
<p>​    1.类和类之间叫做继承（关键字：extends），类和接口之间叫做实现（关键字：implements）。</p>
<p>​    2.当一个<strong>非抽象</strong>的类实现接口的话，必须将接口中所有抽象方法全部实现（覆盖、重写）。</p>
<p>java类名：interfaceTest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class interfaceTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	&#x2F;&#x2F;多态</span><br><span class="line">        &#x2F;&#x2F;父类型的引用指向子类型的对象</span><br><span class="line">        MyMath mm &#x3D; new m();</span><br><span class="line">        &#x2F;&#x2F;面向接口编程</span><br><span class="line">        int sum &#x3D; mm.sum(10, 80);</span><br><span class="line">        int sub &#x3D; mm.sub(20, 5);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(sub);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface MyMath&#123;</span><br><span class="line">    double PI &#x3D; 3.1415926;</span><br><span class="line">    int sum(int a , int b);&#x2F;&#x2F;默认public访问权限</span><br><span class="line">    int sub(int a , int b);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;非抽象类实现接口</span><br><span class="line">class m implements MyMath&#123;</span><br><span class="line">    &#x2F;&#x2F;public不能省略，访问权限不能低于接口的访问权限</span><br><span class="line">    &#x2F;&#x2F;实现接口的方法</span><br><span class="line">    public int sum(int a , int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sub(int a , int b)&#123;</span><br><span class="line">        return a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以同时实现多个接口：</p>
<p>这个机制弥补了Java中类和类之间的单继承（为了简单而出现）带来的缺陷。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class interfaceTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;父类型的引用指向子类型的对象</span><br><span class="line">        A a &#x3D; new C();</span><br><span class="line">        int sum &#x3D; a.sum(10, 20);</span><br><span class="line">        &#x2F;&#x2F;a.sub(20,10);  编译报错，A接口中没有sub（）方法</span><br><span class="line">        &#x2F;*</span><br><span class="line">        *接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强制转换</span><br><span class="line">        但注意：运行时可能出现ClassCastException异常</span><br><span class="line">        *编译没问题，运行有问题</span><br><span class="line">        B b &#x3D; (B) a;</span><br><span class="line">        a.sub(20,10);</span><br><span class="line">        **&#x2F;</span><br><span class="line">        &#x2F;&#x2F;向下转型记得转型前先 if+instanceof 进行判断</span><br><span class="line">        if(a instanceof B) &#123;</span><br><span class="line">            B b &#x3D; (B) a;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        &#x2F;&#x2F;也可以直接向下转型</span><br><span class="line">        C c &#x3D; (C) a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface A&#123;</span><br><span class="line">    public int sum(int a , int b);</span><br><span class="line">&#125;</span><br><span class="line">interface B&#123;</span><br><span class="line">    public int sub(int a , int b);</span><br><span class="line">&#125;</span><br><span class="line">class C implements A&#123;</span><br><span class="line">    public int sum(int a, int b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class equalsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            &#x2F;&#x2F;多态（自动类型转换）</span><br><span class="line">        Object o1&#x3D;new String();</span><br><span class="line">        Object o2&#x3D;new User();</span><br><span class="line">        Object o3&#x3D;new Address();</span><br><span class="line"></span><br><span class="line">        User u1&#x3D;new User(&quot;张三&quot;,new Address(&quot;河南&quot;,&quot;郑州&quot;,&quot;惠济区&quot;));</span><br><span class="line">        User u2&#x3D;new User(&quot;张三&quot;,new Address(&quot;河南&quot;,&quot;郑州&quot;,&quot;惠济区&quot;));</span><br><span class="line">        System.out.println(u1.equals(u2));&#x2F;&#x2F;true</span><br><span class="line">        User u3&#x3D;new User(&quot;李四&quot;,new Address(&quot;河南&quot;,&quot;郑州&quot;,&quot;惠济区&quot;));</span><br><span class="line">        System.out.println(u1.equals(u3));&#x2F;&#x2F;false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address addr;</span><br><span class="line">    public User()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public User(String name,Address addr)&#123;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">        this.addr&#x3D;addr;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;equals重写</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">        if (o &#x3D;&#x3D; null || !(o instanceof User)) return false;</span><br><span class="line">        User user &#x3D; (User) o;</span><br><span class="line">        return name.equals(user.name) &amp;&amp;</span><br><span class="line">                addr.equals(user.addr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> class Address&#123;</span><br><span class="line">    String zipcode;</span><br><span class="line">    String street;</span><br><span class="line">    String city;</span><br><span class="line">    &#x2F;&#x2F;无形参</span><br><span class="line">    public Address()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;有形参</span><br><span class="line">    public Address(String city,String street,String zipcode)&#123;</span><br><span class="line">        this.city&#x3D;city;</span><br><span class="line">        this.street&#x3D;street;</span><br><span class="line">        this.zipcode&#x3D;zipcode;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;equals重写</span><br><span class="line">     @Override</span><br><span class="line">     public boolean equals(Object o) &#123;</span><br><span class="line">         if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">         if (o &#x3D;&#x3D; null || !(o instanceof Address)) return false;</span><br><span class="line">         Address address &#x3D; (Address) o;</span><br><span class="line">         return zipcode.equals(address.zipcode) &amp;&amp;</span><br><span class="line">                 street.equals(address.street) &amp;&amp;</span><br><span class="line">                 city.equals(address.city);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数据这种数据结构的优点和缺点是什么？"><a href="#数据这种数据结构的优点和缺点是什么？" class="headerlink" title="数据这种数据结构的优点和缺点是什么？"></a>数据这种数据结构的优点和缺点是什么？</h3><p>​    优点：查询/查找/检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构。</p>
<p>​        为什么检索效率高？</p>
<p>​            第一：每一个元素的内存地址在空间储存上是连续的。</p>
<p>​            第二：每一个元素类型是相同的，所以占用的空间大小一样。</p>
<p>​             第三：知道每一个元素内存地址，知道每一个元素占用空间的大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标上元素的内存地址。直接通过内存地址定位元素。所以数据的检索效率是高的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class arrayTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] x&#x3D;&#123;1,2,4,3,5&#125;;</span><br><span class="line">        printArray(x);</span><br><span class="line">        &#x2F;&#x2F;创建String数组</span><br><span class="line">        String[] stringArray&#x3D;&#123;&quot;asd&quot;,&quot;asd&quot;,&quot;asa&quot;,&quot;awq&quot;&#125;;</span><br><span class="line">        printArray(stringArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printArray(int[] a) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;a.length ; i++) &#123;</span><br><span class="line">            System.out.println(a[i]);&#x2F;&#x2F;1,2,3,4,5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printArray(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;args.length ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;String数组中的元素：&quot;+args[i]);&#x2F;&#x2F;String数组中的元素：asdString数组中的元素：asdString数组中的元素：asaString数组中的元素：awq</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class arrayCopyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] src &#x3D; &#123;1,2,3,4&#125;;&#x2F;&#x2F;创建拷贝源</span><br><span class="line">       &#x2F;* int[] dest &#x3D; new int[20];&#x2F;&#x2F;创建拷贝目标</span><br><span class="line">        System.arraycopy(src,1,dest,4,3);&#x2F;&#x2F;调用JDK System类中的arraycopy方法，完成数组的拷贝，注意下标是从0开始</span><br><span class="line">        for (int i &#x3D; 0; i &lt;dest.length ; i++) &#123;</span><br><span class="line">            System.out.println(dest[i]);&#x2F;&#x2F;0 0 0 0 2 3 4...0</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        int[] dest &#x3D; new int[10];</span><br><span class="line">        System.arraycopy(src,0,dest,0,src.length);&#x2F;&#x2F;复制拷贝源数组的全部数据</span><br><span class="line">        for (int i &#x3D; 0; i &lt;dest.length ; i++) &#123;</span><br><span class="line">            System.out.println(dest[i]);&#x2F;&#x2F;1 2 3 4 0 0...</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] obj &#x3D; &#123;new Object(),new Object(),new Object()&#125;;</span><br><span class="line">        Object[] o &#x3D; new Object[20];</span><br><span class="line">        System.arraycopy(obj,0,o,0,obj.length);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; o.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;输出obj对象的地址</span><br><span class="line">            System.out.println(o[i]);&#x2F;&#x2F;java.lang.Object@10f87f48 java.lang.Object@b4c966a java.lang.Object@2f4d3709 null null...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class mq &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[]a&#x3D;&#123;1,4,6,2,10,5&#125;;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        for (int i &#x3D; a.length-1; i &gt; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;输出次数</span><br><span class="line">                count++;</span><br><span class="line">                if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">                    int temp &#x3D; a[j];</span><br><span class="line">                    a[j]&#x3D;a[j+1];</span><br><span class="line">                    a[j+1]&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;比较次数:&quot;+count);&#x2F;&#x2F;比较次数:15</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]+&quot; &quot;);&#x2F;&#x2F;1 2 4 5 6 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class select &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[]a&#x3D;&#123;1,4,6,2,10,5&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length-1; i++) &#123;</span><br><span class="line">            int min &#x3D; i;</span><br><span class="line">            for (int j &#x3D; i+1; j &lt; a.length; j++) &#123;</span><br><span class="line">                if(a[j]&lt;a[min])&#123;</span><br><span class="line">                    min&#x3D;j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(min!&#x3D;i)&#123;</span><br><span class="line">                int temp &#x3D; a[min];</span><br><span class="line">                a[min] &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]+&quot; &quot;);&#x2F;&#x2F;1 2 4 5 6 10 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayUtil &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">        int[] a&#x3D;&#123;100,201,300,401,500,600,800,1000&#125;;&#x2F;&#x2F;要求目标序列是拍好序的</span><br><span class="line">        System.out.print(&quot;元素中有：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();&#x2F;&#x2F;转行</span><br><span class="line">        System.out.print(&quot;请输入想要查找下标的元素:&quot;);</span><br><span class="line">        int b &#x3D; in.nextInt();</span><br><span class="line">        int index &#x3D; binarySearch(a,b);</span><br><span class="line">        System.out.println(index &#x3D;&#x3D; -1 ? &quot;该元素不存在！&quot; : &quot;该元素下标：&quot;+index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;@return -1表示该元素不存在，其他的表示返回该元素的下标</span><br><span class="line">    private static int binarySearch(int[] a,int dest) &#123;</span><br><span class="line">        int begin &#x3D; 0;</span><br><span class="line">        int end &#x3D; a.length-1;</span><br><span class="line">        while (begin &lt;&#x3D; end) &#123;</span><br><span class="line">            int mid &#x3D; (begin + end) &#x2F; 2;</span><br><span class="line">            if (a[mid] &#x3D;&#x3D; dest) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (a[mid] &lt; dest) &#123;</span><br><span class="line">                &#x2F;&#x2F;目标在”中间“右边</span><br><span class="line">                &#x2F;&#x2F;开始元素小标需要发生变化</span><br><span class="line">                begin &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;a[mid] &gt; dest</span><br><span class="line">                &#x2F;&#x2F;目标在“中间”左边</span><br><span class="line">                end &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sting类"><a href="#Sting类" class="headerlink" title="Sting类"></a>Sting类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a &#x3D; &quot;a&quot;;</span><br><span class="line">        String b &#x3D; &quot;a&quot;;</span><br><span class="line">        System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F;true</span><br><span class="line">        String c &#x3D; new String(&quot;b&quot;);</span><br><span class="line">        String d &#x3D; new String(&quot;b&quot;);</span><br><span class="line">        System.out.println(c &#x3D;&#x3D; d);&#x2F;&#x2F;false</span><br><span class="line">        &#x2F;&#x2F;所以字符串之间比较不能使用“&#x3D;&#x3D;”，“&#x3D;&#x3D;”不保险，应该调用String类的equals方法</span><br><span class="line">        &#x2F;&#x2F;String类已经重写equals方法</span><br><span class="line">        System.out.println(c.equals(d));&#x2F;&#x2F;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于String类中的构造方法</p>
<p>一、String s =new String(“”);</p>
<p>二、String s = “”;</p>
<p>三、String s =new String(char数组);</p>
<p>四、String s =new String(char数组,起始下标,长度);</p>
<p>五、String s =new String(byte数组);</p>
<p>六、String s =new String(byte数组,起始下标,长度);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] b &#x3D; &#123;97,98,99&#125;;&#x2F;&#x2F;97是a 98是b 99是c</span><br><span class="line">        String s1 &#x3D; new String(b,1,2);</span><br><span class="line">        System.out.println(s1);&#x2F;&#x2F;bc</span><br><span class="line">        char[] c &#x3D; &#123;&#39;我&#39;,&#39;是&#39;,&#39;好&#39;,&#39;人&#39;&#125;;</span><br><span class="line">        String s2 &#x3D; new String(c,2,2);</span><br><span class="line">        System.out.println(s2);&#x2F;&#x2F;好人</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c &#x3D;&quot;我是好人&quot;.charAt(1);</span><br><span class="line">System.out.println(c);&#x2F;&#x2F;国</span><br></pre></td></tr></table></figure>

<h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><p>字符串比较使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; &quot;abc&quot;.compareTo(&quot;abc&quot;);</span><br><span class="line">System.out.println(i);&#x2F;&#x2F;0</span><br><span class="line">int j &#x3D; &quot;abc&quot;.compareTo(&quot;abd&quot;);</span><br><span class="line">System.out.println(j);&#x2F;&#x2F;-1</span><br><span class="line">int h &#x3D; &quot;abd&quot;.compareTo(&quot;abc&quot;);</span><br><span class="line">System.out.println(h);&#x2F;&#x2F;1</span><br><span class="line">int k &#x3D; &quot;bac&quot;.compareTo(&quot;abc&quot;);</span><br><span class="line">System.out.println(k);&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><p>判断前面的字符串是否包含后面的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;HelloWorld&quot;.contains(&quot;Hello&quot;));&#x2F;&#x2F;true</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;.contains(&quot;Helle&quot;));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="endWith"><a href="#endWith" class="headerlink" title="endWith"></a>endWith</h3><p>判断当前字符串是否以某个字符串结尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;HelloWorld.java&quot;.endWith(&quot;.java&quot;));&#x2F;&#x2F;true</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;.endWith(&quot;Helle&quot;));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h3><p>将字符串对象转换成字节数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte[] by &#x3D; &quot;asdasf&quot;.getBytes();</span><br><span class="line">for (int i &#x3D; 0; i &lt; by.length; i++) &#123;</span><br><span class="line">  System.out.println(by[i]);&#x2F;&#x2F;97 115 100 97 115 102 </span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>判断某个子字符串在当前字符串中第一次出现的索引（下标）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;askjhfdiukahdfiuhsad.2315361.kaljhsdfklja&quot;.indexOf(&quot;jhf&quot;));&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><p>判断某个字符串是否为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;&quot;;</span><br><span class="line">System.out.println(s.isEmpty);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>判断数组长度和判断字符串长度不一样</p>
<p>判断数组长度是length属性，判断字符串长度是length()方法</p>
<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><p>判断某个子字符串在当前字符串中最后一次出现的索引（下标）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;askjhfdiukahdfiuhsad.2315361.kaljhsdfklja&quot;.lastIndexOf(&quot;jh&quot;));&#x2F;&#x2F;32</span><br></pre></td></tr></table></figure>

<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D;&quot;www.baidu.com&quot;.replace(&quot;www.&quot;,&quot;http:&#x2F;&#x2F;&quot;);</span><br><span class="line">System.out.println(s);&#x2F;&#x2F;http:&#x2F;&#x2F;baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>拆分字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> String s &#x3D; &quot;www&#x3D;baidu&#x3D;com&quot;;</span><br><span class="line"> String[] ss &#x3D;s.split(&quot;&#x3D;&quot;);</span><br><span class="line"> for (int i &#x3D; 0; i &lt; ss.length; i++) &#123;</span><br><span class="line">     System.out.println(ss[i]);&#x2F;&#x2F;www baidu com</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;HelloWorld.java&quot;.endWith(&quot;Hello&quot;));&#x2F;&#x2F;true</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;.endWith(&quot;World&quot;));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>截取字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;www.baidu.com&quot;;</span><br><span class="line">System.out.println(s.substring(4));&#x2F;&#x2F;baidu.com</span><br><span class="line">System.out.println(s.substring(4,7));&#x2F;&#x2F;bai</span><br></pre></td></tr></table></figure>

<h3 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray()"></a>toCharArray()</h3><p>将字符串转换成char数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char[] c &#x3D; &quot;我是好人&quot;.toCharArray();</span><br><span class="line">for (int i &#x3D; 0; i &lt; c.length; i++) &#123;</span><br><span class="line">   System.out.println(c[i]);&#x2F;&#x2F;我 是 好 人</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toLowerCase-和toUpperCase"><a href="#toLowerCase-和toUpperCase" class="headerlink" title="toLowerCase()和toUpperCase()"></a>toLowerCase()和toUpperCase()</h3><p>转换为大小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;WWWbaiducom&quot;;</span><br><span class="line">System.out.println(s.toUpperCase());&#x2F;&#x2F;WWWBAIDUCOM</span><br><span class="line">System.out.println(s.toLowerCase());&#x2F;&#x2F;wwwbaiducom</span><br></pre></td></tr></table></figure>

<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>去除字符串前后空白</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot; jahsdjkhakjs   askljdklasj   &quot;.trim());&#x2F;&#x2F;jahsdjkhakjs   askljdklasj</span><br></pre></td></tr></table></figure>

<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>将“非字符串”转换成“字符串”</p>
<p>凡是**System.out.println();**的都是字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; String.valueOf(true);&#x2F;&#x2F;true字符串</span><br><span class="line">String s1 &#x3D; String.valueOf(100);&#x2F;&#x2F;100字符串</span><br><span class="line">System.out.println(true);&#x2F;&#x2F;字符串</span><br></pre></td></tr></table></figure>

<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer()"></a>StringBuffer()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建一个初始容量为16个byte[]数组(字符串缓冲区对象)</span><br><span class="line">StringBuffer st &#x3D; new StringBuffer();&#x2F;&#x2F;可以在括号中给定初始化容量</span><br><span class="line">st.append(465);</span><br><span class="line">st.append(&quot;asdad&quot;);</span><br><span class="line">st.append(3.14);</span><br><span class="line">st.append(456L);</span><br><span class="line">System.out.println(st);&#x2F;&#x2F;465asdad3.14456</span><br></pre></td></tr></table></figure>

<h4 id="如何优化StringBuffer的性能？"><a href="#如何优化StringBuffer的性能？" class="headerlink" title="如何优化StringBuffer的性能？"></a>如何优化StringBuffer的性能？</h4><ul>
<li>在创建StringBuffer的时候尽可能的给定一个初始化容量</li>
<li>最好减少底层数组的扩容次数，预估计一下，给一个大一些初始化容量</li>
</ul>
<h4 id="StringBuffer和StringBuilder的区别？"><a href="#StringBuffer和StringBuilder的区别？" class="headerlink" title="StringBuffer和StringBuilder的区别？"></a>StringBuffer和StringBuilder的区别？</h4><ul>
<li>StringBuffer是线程安全的</li>
<li>StringBuild是非线程安全的</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>为什么要再提供8种包装类？</p>
<ul>
<li><p>因为8种基本数据类型不够用。</p>
<p>基本数据类型                                包装类型</p>
<p>byte                                              java.long.Byte（父类Number）</p>
<p>short                                            java.long.Shory（父类Number）</p>
<p>int                                                 java.long.Integer（父类Number）</p>
<p>long                                              java.long.Long（父类Number）</p>
<p>float                                              java.long.Float（父类Number）</p>
<p>double                                         java.long.Double（父类Number）</p>
<p>boolean                                       java.long.Boolean（父类Object）</p>
<p>char                                              java.long.Character（父类Object）</p>
</li>
</ul>
<p>Number是一个抽象类，无法实例化对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本数据类型-（转换）——&gt;引用数据类型（装箱）</span><br><span class="line">Integer i &#x3D; new Integer(456);</span><br><span class="line">&#x2F;&#x2F;引用数据类型-（转换）——&gt;基本数据类型（拆箱）</span><br><span class="line">float f &#x3D; i.floatValue();</span><br><span class="line">System.out.println(f);&#x2F;&#x2F;456.0</span><br></pre></td></tr></table></figure>

<h3 id="MAX-VALUE和MIN-VALUE"><a href="#MAX-VALUE和MIN-VALUE" class="headerlink" title="MAX_VALUE和MIN_VALUE"></a>MAX_VALUE和MIN_VALUE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);&#x2F;&#x2F;2147483647</span><br><span class="line">System.out.println(Integer.MIN_VALUE);&#x2F;&#x2F;-2147483648</span><br></pre></td></tr></table></figure>

<h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>自动装箱：基本数据类型自动转换成包装类（基本数据类型–（自动转换）–&gt;包装类型：自动装箱）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer x &#x3D; 900;</span><br></pre></td></tr></table></figure>

<p>自动拆箱：包装类自动转换成基本数据类型（包装类型–（自动装箱）–&gt;基本数据类型：自动拆箱）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int y &#x3D; x;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer a &#x3D; 128;</span><br><span class="line">Integer b &#x3D; 128;</span><br><span class="line">System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F;false</span><br><span class="line">&#x2F;*java中为了提高程序的执行效率，将[-128到127]之间的所有包装对象提前创建好，放到了一个方法区的“整数型常量池”当中，目的是只要用这个区间的数据不需要再new了，直接从整数型常量池当中取出来*&#x2F;</span><br><span class="line">Integer c &#x3D; 127;</span><br><span class="line">Integer d &#x3D; 127;</span><br><span class="line">System.out.println(c &#x3D;&#x3D; d);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>Date–&gt;String</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date d &#x3D; new Date();</span><br><span class="line">        System.out.println(d);&#x2F;&#x2F;Fri Oct 30 21:04:01 CST 2020</span><br><span class="line">        &#x2F;&#x2F;格式化Data</span><br><span class="line">        SimpleDateFormat sd &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String s &#x3D; sd.format(d);</span><br><span class="line">        System.out.println(s);&#x2F;&#x2F;2020-10-30 21:04:01</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String–&gt;Date</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;String--&gt;Date</span><br><span class="line">        String t &#x3D; &quot;2020-10-30 21:21:50&quot;;</span><br><span class="line">        SimpleDateFormat sd2 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        Date d1 &#x3D; sd2.parse(t);</span><br><span class="line">        System.out.println(d1);&#x2F;&#x2F;Fri Oct 30 21:21:50 CST 2020</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h2><p>获取自1970年1月1日到系统当前时间的总毫秒数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DateTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">        print();</span><br><span class="line">        long end &#x3D;System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;输出耗费&quot;+(end-begin)+&quot;毫秒&quot;);&#x2F;&#x2F;输出耗费9毫秒</span><br><span class="line">    &#125;</span><br><span class="line">    public static void print()&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(&quot;i&#x3D;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DecimalFormat"><a href="#DecimalFormat" class="headerlink" title="DecimalFormat()"></a>DecimalFormat()</h2><p>关于数字的格式化</p>
<p>#代表任意数字</p>
<p>,代表千分位</p>
<p>.代表小数点</p>
<p>0补位</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>属于大数据，精度极高，不属于基本数据类型，属于Java对象（引用数据类型）</p>
<p>专门用在财务方面</p>
<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line">public class random &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建随机数</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        &#x2F;&#x2F;随机产生一个int类型取值范围内的数字</span><br><span class="line">        int i &#x3D; r.nextInt();</span><br><span class="line">        System.out.println(i);&#x2F;&#x2F;-595707239</span><br><span class="line">        &#x2F;&#x2F;产生[0~100]之间的随机数，不能产生101</span><br><span class="line">        int i1 &#x3D; r.nextInt(101);</span><br><span class="line">        System.out.println(i1);&#x2F;&#x2F;11</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Random;</span><br><span class="line">&#x2F;&#x2F;生成5个不相同的随机数</span><br><span class="line">public class random &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random r &#x3D; new Random();</span><br><span class="line">        int[] a &#x3D;new int[5];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        while (index &lt; a.length)&#123;</span><br><span class="line">            int num &#x3D; r.nextInt(6);</span><br><span class="line">            System.out.println(&quot;生成的随机数：&quot;+num);&#x2F;&#x2F;1 4 2 5 2 3</span><br><span class="line">            if(!contain(a,num))&#123;</span><br><span class="line">                a[index++]&#x3D;num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.println(a[i]);&#x2F;&#x2F;1 4 2 5 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean contain(int[] a,int key)&#123;</span><br><span class="line">        &#x2F;*Arrays.sort(a);</span><br><span class="line">        return Arrays.binarySearch(a, key) &gt;&#x3D;0;</span><br><span class="line">        存在bug*&#x2F;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; key)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>如果返回值是2种，建议用Boolean；如果是多种，建议用enum</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class enumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Result r1 &#x3D; divide(10,5);</span><br><span class="line">        Result r2 &#x3D; divide(10,0);</span><br><span class="line">        System.out.println(r1 &#x3D;&#x3D; Result.SUCCESS ? &quot;计算成功&quot; : &quot;计算失败&quot;);&#x2F;&#x2F;计算成功</span><br><span class="line">        System.out.println(r2 &#x3D;&#x3D; Result.SUCCESS ? &quot;计算成功&quot; : &quot;计算失败&quot;);&#x2F;&#x2F;计算失败</span><br><span class="line">    &#125;</span><br><span class="line">    public static Result divide(int a ,int b)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int c &#x3D; a &#x2F; b;</span><br><span class="line">            return Result.SUCCESS;</span><br><span class="line">        &#125; catch(Exception e)&#123;</span><br><span class="line">            return Result.FAIL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Result&#123;</span><br><span class="line">    SUCCESS,FAIL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>Java异常的作用：增强程序健壮性。</p>
<p>Java异常以类和对象的形式存在。</p>
<p>异常对象的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String msg &#x3D; e.getMessage();</span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure>

<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>面试题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class finallyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int r &#x3D; m() ;</span><br><span class="line">        System.out.println(r);  &#x2F;&#x2F;100</span><br><span class="line">    &#125;</span><br><span class="line">    public static int m()&#123;</span><br><span class="line">        int i &#x3D; 100;</span><br><span class="line">        try &#123;</span><br><span class="line">        &#x2F;&#x2F;Java方法中有一条语法规则：return语句一旦执行，整个方法必须结束</span><br><span class="line">            return i;</span><br><span class="line">            &#x2F;&#x2F;System.exit(0);执行后退出JVM，finally语句中的代码不执行</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自己创建异常"><a href="#自己创建异常" class="headerlink" title="自己创建异常"></a>自己创建异常</h2><p>创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;编写一个类继承Exception或者RunTimeException</span><br><span class="line">&#x2F;&#x2F;一个带有String参数的，一个无参数的</span><br><span class="line">public class MyException extends Exception&#123;</span><br><span class="line">   &#x2F;&#x2F;编译时异常</span><br><span class="line">        public MyException()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public MyException(String s)&#123;</span><br><span class="line">            super(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*public class MyException extends RuntimeException&#123;</span><br><span class="line">        &#x2F;&#x2F;运行时异常</span><br><span class="line">    &#125;*&#x2F;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建异常对象(只new了异常对象，并没有手动抛出)</span><br><span class="line">        MyException e &#x3D; new MyException(&quot;用户名不能为空！&quot;);</span><br><span class="line">        &#x2F;&#x2F;打印异常堆栈信息</span><br><span class="line">        e.printStackTrace();&#x2F;&#x2F;MyException: 用户名不能为空！  at MyExceptionTest.main(MyExceptionTest.java:4)</span><br><span class="line">        &#x2F;&#x2F;获取异常简单描述信息</span><br><span class="line">        String m &#x3D; e.getMessage();</span><br><span class="line">        System.out.println(m);&#x2F;&#x2F;用户名不能为空！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>重写之后的方法不能比重写前的方法抛出更多的异常，可以更少</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="所有的实现类："><a href="#所有的实现类：" class="headerlink" title="所有的实现类："></a>所有的实现类：</h3><ul>
<li>ArrayList：底层是数组</li>
<li>LinkedList：底层是双向链表</li>
<li>Vector：底层是数组，线程安全，效率较低，使用较少</li>
<li>HashSet：底层是HashMap，放到HashSet集合中的元素等同于放到HashMap集合key部分</li>
<li>TreeSet：底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合key部分</li>
<li>HashMap：底层是哈希表</li>
<li>Hashtable：底层是哈希表，只不过线程安全的，效率较低，使用较少</li>
<li>Properties：是线程安全的，并且key和value只能存储字符串String</li>
<li>TreeMap：底层是二叉树，TreeMap集合的key可能自动按照大小顺序排序</li>
</ul>
<p>List集合存储元素的特点：</p>
<p>​    有序可重复</p>
<p>​    有序：存进去和取出的顺序相同</p>
<p>Set集合存储元素的特点：</p>
<p>​    无序不可重复</p>
<p>​    无序：存进去和取出的顺序不一定相同</p>
<p>SortedSet集合存储元素的特点：</p>
<p>​    首先是无序不可重复的，但是SortedSet集合中的元素是可排序的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection c &#x3D;new ArrayList();</span><br><span class="line">        c.add(200);&#x2F;&#x2F;自动装箱</span><br><span class="line">        c.add(true);</span><br><span class="line">        c.add(3.14);</span><br><span class="line">        c.add(new Student());</span><br><span class="line">        c.add(new Object());</span><br><span class="line">        c.add(&quot;浩克&quot;);</span><br><span class="line">        System.out.println(&quot;集合中的个数有&quot;+c.size());&#x2F;&#x2F;集合中的个数有6</span><br><span class="line">        boolean b &#x3D; c.contains(&quot;浩克&quot;);</span><br><span class="line">        System.out.println(b);&#x2F;&#x2F;true</span><br><span class="line">        boolean bo &#x3D; c.contains(201);&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(bo);</span><br><span class="line">        c.remove(&quot;浩克&quot;);</span><br><span class="line">        System.out.println(&quot;集合中的个数有&quot;+c.size());&#x2F;&#x2F;集合中的个数有5</span><br><span class="line">        System.out.println(c.isEmpty());&#x2F;&#x2F;false,判断是否为空</span><br><span class="line">        c.clear();</span><br><span class="line">        System.out.println(c.isEmpty());&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(&quot;集合中的个数有&quot;+c.size());&#x2F;&#x2F;集合中的个数有0</span><br><span class="line">        &#x2F;&#x2F;转换成数组,了解，使用不多</span><br><span class="line">        c.add(true);</span><br><span class="line">        c.add(3.14);</span><br><span class="line">        Object[] o &#x3D; c.toArray();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; o.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历数组</span><br><span class="line">            Object ob &#x3D; o[i];</span><br><span class="line">            System.out.println(ob);&#x2F;&#x2F;true 3.14</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">public class MyArraylistTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历&#x2F;迭代方式，是所有Collection通用的一种方式</span><br><span class="line">        &#x2F;&#x2F;在Map集合中不能使用，在所有的Collection以及子类中能使用</span><br><span class="line">        &#x2F;&#x2F;创建集合对象</span><br><span class="line">        Collection c &#x3D; new HashSet();</span><br><span class="line">        c.add(&quot;ac&quot;);</span><br><span class="line">        c.add(3);</span><br><span class="line">        c.add(3.14);</span><br><span class="line">        c.add(new Object());</span><br><span class="line">        &#x2F;&#x2F;对集合进行遍历&#x2F;迭代</span><br><span class="line">        &#x2F;&#x2F;第一步：获取迭代器对象</span><br><span class="line">        Iterator i &#x3D; c.iterator();</span><br><span class="line">        &#x2F;&#x2F;第二步：通过获取的迭代器开始迭代</span><br><span class="line">        &#x2F;*以下两个方法是迭代器对象iterator中的方法：</span><br><span class="line">                boolean hasNext()如果仍有元素可以迭代，则返回true</span><br><span class="line">                Object next() 返回迭代的下一个元素*&#x2F;</span><br><span class="line">        while(i.hasNext())&#123;</span><br><span class="line">            boolean h &#x3D; i.hasNext();</span><br><span class="line">            &#x2F;&#x2F;不管你存进去什么，取出来统一都是Object</span><br><span class="line">            Object o &#x3D; i.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            &#x2F;* java.lang.Object@10f87f48</span><br><span class="line">            ac</span><br><span class="line">            3</span><br><span class="line">            3.14*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代集合和HasSet集合"><a href="#迭代集合和HasSet集合" class="headerlink" title="迭代集合和HasSet集合"></a>迭代集合和HasSet集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">public class MyArrayList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建集合对象</span><br><span class="line">        Collection c &#x3D;  new ArrayList();&#x2F;&#x2F;ArrayList集合：有序可重复</span><br><span class="line">        &#x2F;&#x2F;添加元素</span><br><span class="line">        c.add(1);</span><br><span class="line">        c.add(2);</span><br><span class="line">        c.add(3);</span><br><span class="line">        c.add(1);</span><br><span class="line">        &#x2F;&#x2F;迭代集合</span><br><span class="line">        Iterator i &#x3D; c.iterator();</span><br><span class="line">        while (i.hasNext())&#123;</span><br><span class="line">            Object o &#x3D; i.next();</span><br><span class="line">            System.out.println(o);&#x2F;&#x2F;1 2 3 1</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;HasSet集合：无序不可重复</span><br><span class="line">        Collection co &#x3D; new HashSet();</span><br><span class="line">        &#x2F;&#x2F;无序：存进去的顺序和取出来的顺序不同  不可重复：存进去100后，不能再次存储</span><br><span class="line">        co.add(100);</span><br><span class="line">        co.add(200);</span><br><span class="line">        co.add(300);</span><br><span class="line">        co.add(400);</span><br><span class="line">        co.add(30);</span><br><span class="line">        co.add(40);</span><br><span class="line">        co.add(100);</span><br><span class="line">        Iterator it &#x3D; co.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());&#x2F;&#x2F;400 100 200 40 300 30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h3><p>contains方法是用来判断集合中是否包含某个元素的方法，在底层中调用了equals方法进行比对，返回true。就表示包含这个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">public class mycollection &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建集合对象</span><br><span class="line">        Collection c &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;创建用户对象</span><br><span class="line">        User u1 &#x3D; new User(&quot;李四&quot;);</span><br><span class="line">        User u2 &#x3D; new User(&quot;李四&quot;);</span><br><span class="line">        c.add(u1);</span><br><span class="line">        &#x2F;&#x2F;没重写equals方法之前</span><br><span class="line">        &#x2F;&#x2F;System.out.println(c.contains(u2));&#x2F;&#x2F;false</span><br><span class="line">        &#x2F;&#x2F;重写equals方法之后</span><br><span class="line">        System.out.println(c.contains(u2));&#x2F;&#x2F;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public User()&#123;&#125;</span><br><span class="line">    public User(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重写equals方法</span><br><span class="line">    &#x2F;&#x2F;这个equals方法的比较原理：只要名字一样就表示同一个用户</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null || !(o instanceof User)) return false;</span><br><span class="line">        if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">        User user &#x3D; (User) o;</span><br><span class="line">        &#x2F;&#x2F;如果名字一样，表示同一个人</span><br><span class="line">        return user.name.equals(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">&#x2F;&#x2F;当集合的结构发生改变时，迭代器必须重新获取</span><br><span class="line">public class MycollectionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection c &#x3D;  new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;Iterator i &#x3D; c.iterator();&#x2F;&#x2F;ConcurrentModificationExceptionm,集合结构改变，所以会报错</span><br><span class="line">        c.add(1);</span><br><span class="line">        c.add(2);</span><br><span class="line">        c.add(3);</span><br><span class="line">        c.add(1);</span><br><span class="line">        Iterator i &#x3D; c.iterator();</span><br><span class="line">        while (i.hasNext())&#123;</span><br><span class="line">            Object o &#x3D; i.next();</span><br><span class="line">            &#x2F;&#x2F;c.remove(o);&#x2F;&#x2F;ConcurrentModificationException，迭代器结构改变，在迭代集合工程中，不能调用集合对象的remove方法删除元素</span><br><span class="line">            &#x2F;&#x2F;因为c.remove(o);直接通过集合去删除元素，没有通知迭代器（导致迭代器的快照和原集合状态不同）</span><br><span class="line">            &#x2F;&#x2F;出异常的根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化）</span><br><span class="line">            i.remove();&#x2F;&#x2F;可以使用迭代器删除元素，删除的一定是迭代器指向的当前元素</span><br><span class="line">            &#x2F;&#x2F;迭代器去删除时，会自动更新迭代器，并且更新集合，（删除集合中的元素）</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c.size());&#x2F;&#x2F;元素为0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.*;</span><br><span class="line">&#x2F;*测试List接口中常用的方法</span><br><span class="line">    List集合存储元素的特点：有序可重复</span><br><span class="line">        有序：List集合中的元素有下标。从0开始，以1递增</span><br><span class="line">        可重复：存储一个1，还可以继续存储1*&#x2F;</span><br><span class="line">public class ListTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;List mylist &#x3D; new LinkedList();</span><br><span class="line">        &#x2F;&#x2F;List mylist &#x3D; new Vector();</span><br><span class="line">        List mylist &#x3D; new ArrayList();</span><br><span class="line">        mylist.add(&quot;asd&quot;);&#x2F;&#x2F;默认向集合末尾添加元素</span><br><span class="line">        mylist.add(&quot;aqw&quot;);</span><br><span class="line">        mylist.add(&quot;qwe&quot;);</span><br><span class="line">        mylist.add(1,&quot;li&quot;);&#x2F;&#x2F;在列表指定位置插入指定元素，用的比较少，因为效率较低</span><br><span class="line">        Iterator it &#x3D; mylist.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">            Object o &#x3D; it.next();</span><br><span class="line">            System.out.println(o);&#x2F;&#x2F;asd li aqw qwe</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据下标获取元素</span><br><span class="line">        Object firo &#x3D; mylist.get(2);</span><br><span class="line">        System.out.println(firo);&#x2F;&#x2F;aqw</span><br><span class="line">        &#x2F;&#x2F;因为有下标，所以List集合有自己比较特殊的遍历方式</span><br><span class="line">        &#x2F;&#x2F;通过下标遍历[List集合特有的方法，Set没有]</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mylist.size(); i++) &#123;</span><br><span class="line">            Object obj &#x3D; mylist.get(i);</span><br><span class="line">            System.out.println(obj);&#x2F;&#x2F;asd li aqw qwe</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取指定对象第一次出现处的索引</span><br><span class="line">        System.out.println(mylist.indexOf(&quot;qwe&quot;));&#x2F;&#x2F;3</span><br><span class="line">        &#x2F;&#x2F;获取指定对象最后一次出现处的索引</span><br><span class="line">        System.out.println(mylist.lastIndexOf(&quot;li&quot;));&#x2F;&#x2F;1</span><br><span class="line">        &#x2F;&#x2F;删除指定下标位置的元素</span><br><span class="line">        mylist.remove(3);</span><br><span class="line">        System.out.println(mylist.size());&#x2F;&#x2F;3</span><br><span class="line">        &#x2F;&#x2F;修改指定位置的元素</span><br><span class="line">        mylist.set(2,&quot;yun&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mylist.size(); i++) &#123;</span><br><span class="line">            Object b &#x3D; mylist.get(i);</span><br><span class="line">            System.out.println(b);&#x2F;&#x2F;asd li yun</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试官常问一个问题：</strong>你用哪个集合比较多</p>
<p>​        答：ArrayList集合。因为往数组末尾添加元素，效率不受影响。另外，我们检索/查找某个元素的操作比较多</p>
<ul>
<li><p>数组优点：</p>
<ul>
<li>检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存的地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高）</li>
</ul>
</li>
<li><p>数组缺点：</p>
<ul>
<li>随机增删元素效率比较低</li>
<li>另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间）</li>
</ul>
</li>
</ul>
<h2 id="单项链表"><a href="#单项链表" class="headerlink" title="单项链表"></a>单项链表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package danLike;</span><br><span class="line"></span><br><span class="line">public class Link &#123;</span><br><span class="line">    Node header;</span><br><span class="line">    int size;</span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加元素的方法</span><br><span class="line">    public void add(Object data)&#123;</span><br><span class="line">        if(header &#x3D;&#x3D; null)&#123;</span><br><span class="line">            header &#x3D; new Node(data , null);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            Node currentLastNode &#x3D; findLast(header);</span><br><span class="line">            currentLastNode.next &#x3D; new Node(data,null);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node findLast(Node node) &#123;</span><br><span class="line">        if (node.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return findLast(node.next);&#x2F;&#x2F;递归算法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除元素的方法</span><br><span class="line">    public void remove(Object obj)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;修改元素的方法</span><br><span class="line">    public void modify(Object newobj)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;查找元素的方法</span><br><span class="line">    public void find()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package VectorTest;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Vector中所有的方法都是线程同步，都带有synchronizedList关键字</span><br><span class="line">&#x2F;&#x2F;是线程安全，效率比较低，使用较少</span><br><span class="line">public class VectorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Vector v &#x3D; new Vector();</span><br><span class="line">        &#x2F;&#x2F;添加元素，默认容量10个</span><br><span class="line">        v.add(&quot;1&quot;);</span><br><span class="line">        v.add(&quot;2&quot;);</span><br><span class="line">        v.add(&quot;3&quot;);</span><br><span class="line">        v.add(&quot;4&quot;);</span><br><span class="line">        v.add(&quot;5&quot;);</span><br><span class="line">        v.add(&quot;6&quot;);</span><br><span class="line">        v.add(&quot;7&quot;);</span><br><span class="line">        v.add(&quot;8&quot;);</span><br><span class="line">        v.add(&quot;9&quot;);</span><br><span class="line">        v.add(&quot;10&quot;);</span><br><span class="line">        &#x2F;&#x2F;满了之后扩容为20</span><br><span class="line">        v.add(&quot;11&quot;);</span><br><span class="line">        Iterator iterator &#x3D; v.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Object o &#x3D; iterator.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以后可能要用，非线程安全ArrayList转变为线程安全Collections</span><br><span class="line">        List myList &#x3D; new ArrayList();&#x2F;&#x2F;非线程安全</span><br><span class="line">        &#x2F;&#x2F;变为线程安全</span><br><span class="line">        Collections.synchronizedList(myList);</span><br><span class="line">        myList.add(&quot;111&quot;);</span><br><span class="line">        myList.add(&quot;222&quot;);</span><br><span class="line">        myList.add(&quot;333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">public class GenericTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;* &#x2F;&#x2F;不适用泛型，分析程序缺点</span><br><span class="line">        List myList &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;准备对象</span><br><span class="line">        Cat cat &#x3D; new Cat();</span><br><span class="line">        Bird bird &#x3D; new Bird();</span><br><span class="line">        &#x2F;&#x2F;将对象添加到集合中</span><br><span class="line">        myList.add(cat);</span><br><span class="line">        myList.add(bird);</span><br><span class="line">        Iterator i &#x3D; myList.iterator();</span><br><span class="line">        while (i.hasNext())&#123;</span><br><span class="line">            Object o &#x3D; i.next();</span><br><span class="line">            if(o instanceof Animals)&#123;</span><br><span class="line">                Animals a &#x3D;(Animals)o;</span><br><span class="line">                a.move();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;使用JDK5之后的泛型机制</span><br><span class="line">        &#x2F;&#x2F;使用泛型List&lt;Animals&gt;之后，表示List集合中只允许存储Animals类型的数据</span><br><span class="line">        &#x2F;&#x2F;用泛型来指定集合中存储的数据类型</span><br><span class="line">        List&lt;Animals&gt; myList &#x3D; new ArrayList&lt;Animals&gt;();</span><br><span class="line">        Cat cat &#x3D; new Cat();</span><br><span class="line">        Bird bird &#x3D; new Bird();</span><br><span class="line">        &#x2F;&#x2F;将对象添加到集合中</span><br><span class="line">        myList.add(cat);</span><br><span class="line">        myList.add(bird);</span><br><span class="line">        Iterator&lt;Animals&gt; i &#x3D; myList.iterator();</span><br><span class="line">        while (i.hasNext())&#123;</span><br><span class="line">            Animals a &#x3D; i.next();</span><br><span class="line">            &#x2F;&#x2F;a.move();</span><br><span class="line">            if (a instanceof Cat)&#123;</span><br><span class="line">                Cat c &#x3D;(Cat)a;</span><br><span class="line">                c.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">            if (a instanceof Bird)&#123;</span><br><span class="line">                Bird b &#x3D;(Bird)a;</span><br><span class="line">                b.fly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animals&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;动物在移动！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animals&#123;</span><br><span class="line">    public void catchMouse()&#123;</span><br><span class="line">        System.out.println(&quot;猫抓老鼠！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Bird extends Animals&#123;</span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        System.out.println(&quot;鸟儿在飞！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的自动类型推断机制"><a href="#泛型的自动类型推断机制" class="headerlink" title="泛型的自动类型推断机制"></a>泛型的自动类型推断机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;&#x2F;JDK引入：自动类型推断机制（又称为钻石表达式）</span><br><span class="line">public class GenericTest02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Animals&gt; myList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        Cat c &#x3D; new Cat();</span><br><span class="line">        Bird b &#x3D; new Bird();</span><br><span class="line">        myList.add(c);</span><br><span class="line">        myList.add(b);</span><br><span class="line">        Iterator&lt;Animals&gt; i &#x3D; myList.iterator();</span><br><span class="line">        while (i.hasNext())&#123;</span><br><span class="line">            Animals a &#x3D; i.next();</span><br><span class="line">            a.move();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; s &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        s.add(&quot;www.baidu.com&quot;);</span><br><span class="line">        s.add(&quot;http:&#x2F;&#x2F;zsquw5.coding-pages.com&#x2F;post&#x2F;8df0ec14.html&quot;);</span><br><span class="line">        s.add(&quot;https:&#x2F;&#x2F;solitudehero.github.io&#x2F;&quot;);</span><br><span class="line">        Iterator&lt;String&gt; it &#x3D; s.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">&#x2F;*            &#x2F;&#x2F;如果不使用泛型</span><br><span class="line">            Object o &#x3D; it.next();</span><br><span class="line">            if (o instanceof String)&#123;</span><br><span class="line">                String ss &#x3D; (String)o;</span><br><span class="line">                ss.substring(0);</span><br><span class="line">            &#125;*&#x2F;</span><br><span class="line">            String s1 &#x3D; it.next();</span><br><span class="line">            String newString &#x3D; s1.substring(0);</span><br><span class="line">            System.out.println(newString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class foreachTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;1,2,3,4,5,6&#125;;</span><br><span class="line">        &#x2F;&#x2F;增强for（foreach）</span><br><span class="line">        &#x2F;&#x2F;foreach缺点是没有下标</span><br><span class="line">        for (int data : arr)&#123;</span><br><span class="line">            &#x2F;&#x2F;data是数组中的元素</span><br><span class="line">            System.out.println(data);&#x2F;&#x2F;1 2 3 4 5 6</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>无序不可重复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class HashSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; s &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        s.add(&quot;3&quot;);</span><br><span class="line">        s.add(&quot;2&quot;);</span><br><span class="line">        s.add(&quot;3&quot;);</span><br><span class="line">        s.add(&quot;4&quot;);</span><br><span class="line">        s.add(&quot;1&quot;);</span><br><span class="line">        &#x2F;&#x2F;放到HashSet集合中的元素实际上是放到HashMap集合的key部分</span><br><span class="line">        for (String str : s)&#123;</span><br><span class="line">            System.out.println(str);&#x2F;&#x2F;1 2 3 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; s &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">        s.add(&quot;a&quot;);</span><br><span class="line">        s.add(&quot;B&quot;);</span><br><span class="line">        s.add(&quot;b&quot;);</span><br><span class="line">        s.add(&quot;A&quot;);</span><br><span class="line">        s.add(&quot;E&quot;);</span><br><span class="line">        s.add(&quot;B&quot;);</span><br><span class="line">        &#x2F;&#x2F;无序不可重复，但是存储的元素可以按照大小顺序排序 称为：可排序集合</span><br><span class="line">        for (String st : s)&#123;</span><br><span class="line">            System.out.println(st);&#x2F;&#x2F;A B E a b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="常用的方法（一）"><a href="#常用的方法（一）" class="headerlink" title="常用的方法（一）"></a>常用的方法（一）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class Maptest01 &#123;</span><br><span class="line">&#x2F;*    java.util.Map接口中常用的方法：</span><br><span class="line">            1.Map和Collection没有继承关系</span><br><span class="line">            2.Map集合以key和value的方式存储数据：键值对</span><br><span class="line">                key和value都是引用数据类型</span><br><span class="line">                key和value都是存储对象的内存地址</span><br><span class="line">                key起主导地位，value是key的一个附属品*&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建Map集合对象</span><br><span class="line">        Map&lt;Integer,String&gt; m &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        m.put(1,&quot;1&quot;);</span><br><span class="line">        m.put(2,&quot;2&quot;);</span><br><span class="line">        m.put(3,&quot;3&quot;);</span><br><span class="line">        m.put(4,&quot;4&quot;);</span><br><span class="line">        m.put(5,&quot;5&quot;);</span><br><span class="line">        &#x2F;&#x2F;通过key获取value</span><br><span class="line">        String v &#x3D; m.get(1);&#x2F;&#x2F;1</span><br><span class="line">        System.out.println(v);</span><br><span class="line">        &#x2F;&#x2F;获取键值对的数量</span><br><span class="line">        System.out.println(&quot;键值对的数量：&quot;+m.size());&#x2F;&#x2F;键值对的数量：5</span><br><span class="line">        &#x2F;&#x2F;通过key删除key-value</span><br><span class="line">        m.remove(2);</span><br><span class="line">        System.out.println(&quot;键值对的数量：&quot;+m.size());&#x2F;&#x2F; 键值对的数量：4</span><br><span class="line">        &#x2F;&#x2F;判断是否包含某个key</span><br><span class="line">        System.out.println(m.containsKey(4));&#x2F;&#x2F;true</span><br><span class="line">        &#x2F;&#x2F;判断是否包含某个value</span><br><span class="line">        System.out.println(m.containsValue(&quot;4&quot;));&#x2F;&#x2F;true</span><br><span class="line">        &#x2F;&#x2F;获取所有的values</span><br><span class="line">        Collection&lt;String&gt; c &#x3D; m.values();</span><br><span class="line">        for(String s : c)&#123;</span><br><span class="line">            System.out.println(s);&#x2F;&#x2F;1 3 4 5</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;清空键值对数量</span><br><span class="line">        m.clear();</span><br><span class="line">        System.out.println(&quot;键值对的数量：&quot;+m.size());&#x2F;&#x2F; 键值对的数量：0</span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        System.out.println(m.isEmpty());&#x2F;&#x2F;true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用的方法（二）"><a href="#常用的方法（二）" class="headerlink" title="常用的方法（二）"></a>常用的方法（二）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class Maptest02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;第一种方法：通过遍历key来遍历values</span><br><span class="line">        Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(1,&quot;1&quot;);</span><br><span class="line">        map.put(2,&quot;2&quot;);</span><br><span class="line">        map.put(3,&quot;3&quot;);</span><br><span class="line">        map.put(4,&quot;4&quot;);</span><br><span class="line">        map.put(5,&quot;5&quot;);</span><br><span class="line">        Set&lt;Integer&gt; keys &#x3D; map.keySet();</span><br><span class="line">        &#x2F;&#x2F;迭代器可以</span><br><span class="line">        Iterator&lt;Integer&gt; it &#x3D; keys.iterator();</span><br><span class="line">        while (it.hasNext())&#123;</span><br><span class="line">            Integer key &#x3D; it.next();</span><br><span class="line">            &#x2F;&#x2F;通过key获取values</span><br><span class="line">            String value &#x3D; map.get(key);</span><br><span class="line">            System.out.println(key + &quot;&#x3D;&quot; + value);&#x2F;&#x2F;1&#x3D;1 2&#x3D;2 3&#x3D;3 4&#x3D;4 5&#x3D;5</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;foreach也行</span><br><span class="line">        for(Integer key : keys)&#123;</span><br><span class="line">            System.out.println(key + &quot;&#x3D;&quot; + map.get(key));&#x2F;&#x2F;1&#x3D;1 2&#x3D;2 3&#x3D;3 4&#x3D;4 5&#x3D;5</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第二种方法：Set&lt;Map,Entry&lt;K,V&gt; entrySet()&gt;</span><br><span class="line">        &#x2F;&#x2F;以上这种方法就是把Map集合全部转换为Set集合</span><br><span class="line">        &#x2F;&#x2F;Set集合中的元素的类型是：Map.Entry</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set &#x3D; map.entrySet();</span><br><span class="line">        &#x2F;&#x2F;遍历Set集合，每一次取出一个Node</span><br><span class="line">&#x2F;*        &#x2F;&#x2F;迭代器</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; ite &#x3D; set.iterator();</span><br><span class="line">        while (ite.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; node &#x3D; ite.next();</span><br><span class="line">            Integer key &#x3D; node.getKey();</span><br><span class="line">            String value &#x3D; node.getValue();</span><br><span class="line">            System.out.println(key + &quot; &#x3D; &quot; + value);&#x2F;&#x2F;1&#x3D;1 2&#x3D;2 3&#x3D;3 4&#x3D;4 5&#x3D;5</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;foreach,效率比较高</span><br><span class="line">        for (Map.Entry&lt;Integer,String&gt; node : set)&#123;</span><br><span class="line">            System.out.println(node.getKey() + &quot; ----&gt; &quot; + node.getValue());&#x2F;&#x2F;1 ----&gt; 1 2 ----&gt; 2 3 ----&gt; 3 4 ----&gt; 4 5 ----&gt; 5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同时重写hashCode和equals"><a href="#同时重写hashCode和equals" class="headerlink" title="同时重写hashCode和equals"></a>同时重写hashCode和equals</h3><ul>
<li>Student类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bean;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public Student()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        &#x2F;&#x2F;重写equals</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;*    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null || !(o instanceof Student)) return false;</span><br><span class="line">        if (o &#x3D;&#x3D; this) return true;</span><br><span class="line">        Student s &#x3D; (Student) o;</span><br><span class="line">        return this.name.equals(s.name);</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; o) return true;</span><br><span class="line">        if (o &#x3D;&#x3D; null || getClass() !&#x3D; o.getClass()) return false;</span><br><span class="line">        Student student &#x3D; (Student) o;</span><br><span class="line">        return Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMapTest02</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package bean;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">&#x2F;&#x2F;1.向Map集合中存，和从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！equals方法可能调用，也可能不调用</span><br><span class="line">&#x2F;&#x2F;2.如果一个类的equals方法重写了，那么hashCode()方法必须重写</span><br><span class="line">&#x2F;&#x2F;并且equals方法返回如果是true，hashCode()方法返回的值必须一样</span><br><span class="line">public class HashMapTest02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 &#x3D; new Student(&quot;张三&quot;);</span><br><span class="line">        Student s2 &#x3D; new Student(&quot;张三&quot;);</span><br><span class="line">&#x2F;*        &#x2F;&#x2F;重写equals前</span><br><span class="line">        System.out.println(s1.equals(s2));&#x2F;&#x2F;false*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;重写equals后</span><br><span class="line">        System.out.println(s1.equals(s2));&#x2F;&#x2F;true&#39;</span><br><span class="line">        System.out.println(&quot;s1的hashCode&#x3D;&quot;+s1.hashCode());&#x2F;&#x2F;s1的hashCode&#x3D;189568618</span><br><span class="line">        System.out.println(&quot;s1的hashCode&#x3D;&quot;+s2.hashCode());&#x2F;&#x2F;s1的hashCode&#x3D;666641942</span><br><span class="line">        &#x2F;&#x2F;s1.equals(s2)结果是true，表示s1和s2是一样的，那么往HashSet集合中放，按说只能放进去一个（HashSet集合特点：无序不可重复）</span><br><span class="line">        Set&lt;Student&gt; students &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        students.add(s1);</span><br><span class="line">        students.add(s2);</span><br><span class="line">        System.out.println(students.size());&#x2F;&#x2F;这个结果按理说是1，但实际上是2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">&#x2F;&#x2F;Properties是一个Map集合，继承HashTable，Properties的key和value都是String类型</span><br><span class="line">&#x2F;&#x2F;Properties被称为属性类对象</span><br><span class="line">&#x2F;&#x2F;Properties是线程安全的</span><br><span class="line">public class PropertiesTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        pro.setProperty(&quot;username&quot;,&quot;root&quot;);</span><br><span class="line">        pro.setProperty(&quot;password&quot;,&quot;123&quot;);</span><br><span class="line">        &#x2F;&#x2F;通过key获取value</span><br><span class="line">        String username &#x3D; pro.getProperty(&quot;username&quot;);</span><br><span class="line">        String password &#x3D; pro.getProperty(&quot;password&quot;);</span><br><span class="line">        System.out.println(username);&#x2F;&#x2F;root</span><br><span class="line">        System.out.println(password);&#x2F;&#x2F;123</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现比较接口"><a href="#实现比较接口" class="headerlink" title="实现比较接口"></a>实现比较接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">public class TreeSetTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;*&#x2F;&#x2F;给构造方法传递一个比较器</span><br><span class="line">        TreeSet&lt;Wugui&gt; wg &#x3D; new TreeSet&lt;&gt;(new WuguiComparator());*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;匿名内部类</span><br><span class="line">        TreeSet&lt;Wugui&gt; wg &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;Wugui&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Wugui o1, Wugui o2) &#123;</span><br><span class="line">                return o1.age-o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        wg.add(new Wugui(100));</span><br><span class="line">        wg.add(new Wugui(1000));</span><br><span class="line">        wg.add(new Wugui(200));</span><br><span class="line">        wg.add(new Wugui(400));</span><br><span class="line">        wg.add(new Wugui(500));</span><br><span class="line">        for (Wugui w : wg)&#123;</span><br><span class="line">            System.out.println(w);</span><br><span class="line">&#x2F;*          乌龟&#123;年龄100&#125;</span><br><span class="line">            乌龟&#123;年龄200&#125;</span><br><span class="line">            乌龟&#123;年龄400&#125;</span><br><span class="line">            乌龟&#123;年龄500&#125;</span><br><span class="line">            乌龟&#123;年龄1000&#125;*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wugui&#123;</span><br><span class="line">     int age;</span><br><span class="line">    public Wugui(int age)&#123;</span><br><span class="line">         this.age &#x3D; age;</span><br><span class="line">     &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;乌龟&#123;&quot; +</span><br><span class="line">                &quot;年龄&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F;自己编辑比较器</span><br><span class="line">class WuguiComparator implements Comparator&lt;Wugui&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Wugui o1, Wugui o2) &#123;</span><br><span class="line">        return o1.age-o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package collec;</span><br><span class="line">import java.util.*;</span><br><span class="line">&#x2F;&#x2F;Collection集合接口,Collections集合工具类，方便集合操作</span><br><span class="line">public class CollectionsTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;ArrayList集合不是线程安全的</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;变成线程安全</span><br><span class="line">        Collections.synchronizedList(list);</span><br><span class="line">        &#x2F;&#x2F;排序</span><br><span class="line">        list.add(&quot;123&quot;);</span><br><span class="line">        list.add(&quot;564&quot;);</span><br><span class="line">        list.add(&quot;547&quot;);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        for(String s : list)&#123;</span><br><span class="line">            System.out.println(s);&#x2F;&#x2F;123 547 564</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Wugui2&gt; wugui &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        wugui.add(new Wugui2(100));</span><br><span class="line">        wugui.add(new Wugui2(1000));</span><br><span class="line">        wugui.add(new Wugui2(1521));</span><br><span class="line">        wugui.add(new Wugui2(1060));</span><br><span class="line">        &#x2F;&#x2F;注意：对List集合中的元素排序，需要保证list集合中的元素实现了：Comparable接口</span><br><span class="line">        Collections.sort(wugui);</span><br><span class="line">        for (Wugui2 w : wugui)&#123;</span><br><span class="line">            System.out.println(w);&#x2F;&#x2F;乌龟&#123;年龄100&#125; 乌龟&#123;年龄1000&#125; 乌龟&#123;年龄1060&#125; 乌龟&#123;年龄1521&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;对Set集合排序</span><br><span class="line">        Set&lt;String&gt; s &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        s.add(&quot;526&quot;);</span><br><span class="line">        s.add(&quot;589&quot;);</span><br><span class="line">        s.add(&quot;532&quot;);</span><br><span class="line">        s.add(&quot;545&quot;);</span><br><span class="line">        &#x2F;&#x2F;将Set集合转换为List集合</span><br><span class="line">        List&lt;String&gt; l &#x3D; new ArrayList&lt;&gt;(s);</span><br><span class="line">        Collections.sort(l);</span><br><span class="line">        for (String s1 : l)&#123;</span><br><span class="line">            System.out.println(s1);&#x2F;&#x2F;526 532 545 589</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wugui2 implements Comparable&lt;Wugui2&gt; &#123;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public Wugui2(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Wugui2 o) &#123;</span><br><span class="line">        return this.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;乌龟&#123;&quot; +</span><br><span class="line">                &quot;年龄&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p><strong>什么是IO流?</strong></p>
<ul>
<li>通过IO可以完成硬盘文件的读和写。</li>
</ul>
<p><strong>IO流的分类？</strong></p>
<ul>
<li><p>一种是按照流的方向进行分类：</p>
<ul>
<li>以内存作为参照物<ul>
<li>往内存中去，叫做输入，或者叫做读</li>
<li>往内存中出来，叫做输出，或者叫做写</li>
</ul>
</li>
</ul>
</li>
<li><p>另一种方式是按照读取数据方式不同进行分类：</p>
<ul>
<li>有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。</li>
<li>这种流是万能的，什么类型都可以读取。包括文本文件，图片….<ul>
<li>假设文件file.txt，采用字节流的话读取：<ul>
<li>a中国bc</li>
<li>第一次读：一个字节，正好读到’a’</li>
<li>第二次读：一个字节，正好读到’中’字符的一半</li>
</ul>
</li>
</ul>
</li>
<li>有的流是按照字符的方式读取数据，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片，声音….只能读取文本文件，连word文件都不能读取。<ul>
<li>假设文件file.txt，采用字符流的话读取：<ul>
<li>a中国bc</li>
<li>第一次读：’a’字符（’a’字符在Windows系统中占用1个字节）</li>
<li>第二次读：’中’字符（’中’字符在Windows系统中占用2个字节）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：在Java中只要“类名”以Stream结尾的都是字节流，以“Reader/Writer”结尾都是字符流</strong></p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>文档放入：abcde</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;*</span><br><span class="line">java.io.FileInputStream:</span><br><span class="line">    1.文件字节输入流，万能的，任何类型的文件都可以采用这个流来读</span><br><span class="line">    2.字节的方式，完成输入的操作，完成读的操作（硬盘——&gt;内存）</span><br><span class="line">*&#x2F;</span><br><span class="line">public class FileInputStreamTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream f &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;创建文件字节输入流对象</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;FileInputStream f &#x3D; new FileInputStream(&quot;G:\\temp.txt&quot;);</span><br><span class="line">            f &#x3D; new FileInputStream(&quot;G:&#x2F;temp.txt&quot;);&#x2F;&#x2F;也可以这么写</span><br><span class="line">            &#x2F;&#x2F;开始读</span><br><span class="line">            int read &#x3D; f.read();&#x2F;&#x2F;这个方法的返回值是：读取到的“字节”本身</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;97</span><br><span class="line">            read &#x3D; f.read();&#x2F;&#x2F;97</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;98</span><br><span class="line">            read &#x3D; f.read();</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;99</span><br><span class="line">            read &#x3D; f.read();</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;100</span><br><span class="line">            read &#x3D; f.read();</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;101</span><br><span class="line">            &#x2F;&#x2F;已经读到了文件的末尾，再读的时候已经读不到任何数据了，返回-1</span><br><span class="line">            read &#x3D; f.read();</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;-1</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;在finally语句块中确保流关闭</span><br><span class="line">            if (f &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;避免空指针异常</span><br><span class="line">                &#x2F;&#x2F;关闭流的前提是：流是null的时候没必要关闭</span><br><span class="line">                try &#123;</span><br><span class="line">                    f.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环输出"><a href="#循环输出" class="headerlink" title="循环输出"></a>循环输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class FileInputStreamTest02 &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line">程序缺点：</span><br><span class="line">	一次读取一个字节byte，这样内存和硬盘交互太频繁，基本时间都浪费在交互上面。</span><br><span class="line">*&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    FileInputStream f &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;创建文件字节输入流对象</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;FileInputStream f &#x3D; new FileInputStream(&quot;G:\\101&quot;);</span><br><span class="line">        f &#x3D; new FileInputStream(&quot;G:&#x2F;temp.txt&quot;);&#x2F;&#x2F;也可以这么写</span><br><span class="line">        &#x2F;&#x2F;循环读</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            int read &#x3D; f.read();</span><br><span class="line">            if (read &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(read);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;改造while循环</span><br><span class="line">        int readdate &#x3D; 0;</span><br><span class="line">        while ((readdate &#x3D; f.read()) !&#x3D; -1)&#123;</span><br><span class="line">            System.out.println(readdate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;在finally语句块中确保流关闭</span><br><span class="line">        if (f &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;避免空指针异常</span><br><span class="line">            &#x2F;&#x2F;关闭流的前提是：流是null的时候没必要关闭</span><br><span class="line">            try &#123;</span><br><span class="line">                f.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建byte数组"><a href="#创建byte数组" class="headerlink" title="创建byte数组"></a>创建byte数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;*int read(byte[] b)</span><br><span class="line">    一次最多读取b.length个字节</span><br><span class="line">    减少硬盘和内存你的交互，提高程序的执行效率</span><br><span class="line">    在byte[]数组当中读*&#x2F;</span><br><span class="line">public class FileInputStreamTest03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            FileInputStream f &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;相对路径是工程Project的根就是IDEA的默认当前路径</span><br><span class="line">            f &#x3D; new FileInputStream(&quot;temp.txt&quot;);</span><br><span class="line">            &#x2F;&#x2F;开始读，采用byte数组，一次读取多个字节，最多读取“数组.length”个字节</span><br><span class="line">            byte[] bytes &#x3D; new byte[4];</span><br><span class="line">            &#x2F;&#x2F;这个方法的返回值是：读取到的字节数量（不是字节本身）</span><br><span class="line">            int read &#x3D; f.read(bytes);</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;第一次读取到了4个字节</span><br><span class="line">            &#x2F;&#x2F;将字节转换成字符串</span><br><span class="line">&#x2F;&#x2F;            System.out.println(new String(bytes));&#x2F;&#x2F;abcd</span><br><span class="line">            &#x2F;&#x2F;不应该全部都转换，应该是读取多少个字节，转换多少个</span><br><span class="line">            System.out.println(new String(bytes,0,read));&#x2F;&#x2F;abcd</span><br><span class="line">            read &#x3D; f.read(bytes);</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;第二次读到了1个字节&#39;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(new String(bytes));&#x2F;&#x2F;ebcd</span><br><span class="line">            &#x2F;&#x2F;不应该全部都转换，应该是读取多少个字节，转换多少个</span><br><span class="line">            System.out.println(new String(bytes,0,read));&#x2F;&#x2F;e</span><br><span class="line">            read &#x3D; f.read(bytes);</span><br><span class="line">            System.out.println(read);&#x2F;&#x2F;一个字节都没有读取到 -1</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (f !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    f.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;&#x2F;最终版</span><br><span class="line">public class FileInputStreamTest04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream f &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                f &#x3D; new FileInputStream(&quot;temp.txt&quot;);</span><br><span class="line">                byte[] bytes &#x3D; new byte[4];</span><br><span class="line">                &#x2F;*while (true)&#123;</span><br><span class="line">                    int read &#x3D; f.read(bytes);</span><br><span class="line">                    if (read &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;把byte数组转换成字符串</span><br><span class="line">                    System.out.print(new String(bytes,0,read));&#x2F;&#x2F;abcde</span><br><span class="line">                &#125;*&#x2F;</span><br><span class="line">                int read &#x3D; 0;</span><br><span class="line">                while ((read &#x3D; f.read(bytes)) !&#x3D; -1)&#123;</span><br><span class="line">                    System.out.print(new String(bytes,0,read));&#x2F;&#x2F;abcde</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (f !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileInputStream类的其他常用方法"><a href="#FileInputStream类的其他常用方法" class="headerlink" title="FileInputStream类的其他常用方法"></a>FileInputStream类的其他常用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;*FileInputStream类的其他常用方法：</span><br><span class="line">        int available()：返回流当中剩余的没有读到的字节数量</span><br><span class="line">        long skip(long n)：跳过几个字节不读*&#x2F;</span><br><span class="line">public class FileInputStreamTest05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream f &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            f &#x3D; new FileInputStream(&quot;temp.txt&quot;);&#x2F;&#x2F;总字节数量：5</span><br><span class="line">            &#x2F;*System.out.println(&quot;总字节数量：&quot;+f.available());</span><br><span class="line">            &#x2F;&#x2F;读1个字节</span><br><span class="line">            int read &#x3D; f.read();</span><br><span class="line">            &#x2F;&#x2F;还剩下4个字节</span><br><span class="line">            System.out.println(&quot;剩下多少个字节没读：&quot;+f.available());&#x2F;&#x2F;剩下多少个字节没读：4*&#x2F;</span><br><span class="line">            &#x2F;&#x2F;skip</span><br><span class="line">            f.skip(4);</span><br><span class="line">            System.out.println(f.read());&#x2F;&#x2F;101</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (f !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    f.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class FileOutputStreamTest01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileOutputStream f &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;myfile文件不存在时，会自动新建</span><br><span class="line">            &#x2F;&#x2F;这种方式谨慎使用，这种方式会将原文件清空，然后重新写入</span><br><span class="line">&#x2F;&#x2F;            f &#x3D; new FileOutputStream(&quot;myfile&quot;);</span><br><span class="line">            &#x2F;&#x2F;以追加方式在文件末尾写入，不会清空原文件内容</span><br><span class="line">            f &#x3D; new FileOutputStream(&quot;myfile&quot;,true);</span><br><span class="line">            &#x2F;&#x2F;写完之后，最后一定要刷新</span><br><span class="line">            byte[] bytes &#x3D; &#123;97,98,99,100&#125;;</span><br><span class="line">            &#x2F;&#x2F;将byte数组全部写出</span><br><span class="line">            f.write(bytes);&#x2F;&#x2F;abcd</span><br><span class="line">            &#x2F;&#x2F;将byte数组的一部分写出</span><br><span class="line">            f.write(bytes,0,3);&#x2F;&#x2F;abc</span><br><span class="line">            String s &#x3D; &quot;我是一个中国人，我骄傲&quot;;</span><br><span class="line">            &#x2F;&#x2F;将字符串转换为byte数组</span><br><span class="line">            byte[] bs &#x3D; s.getBytes();</span><br><span class="line">            f.write(bs);</span><br><span class="line">            f.flush();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (f !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    f.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">&#x2F;&#x2F;使用FileInputStream+FileOutputStream完成文件的拷贝。</span><br><span class="line">&#x2F;&#x2F;拷贝过程是一边读一边写</span><br><span class="line">public class copy01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        FileOutputStream fos &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(&quot;C:\\Users\\lyl93\\Downloads\\Programs\\WeGameMiniLoader.std.2.07.29.1736.exe&quot;);</span><br><span class="line">            fos &#x3D; new FileOutputStream(&quot;D:&#x2F;WeGameMiniLoader.std.2.07.29.1736.exe&quot;);</span><br><span class="line">            &#x2F;&#x2F;最核心：一边读一边写</span><br><span class="line">            byte[] bytes &#x3D; new byte[1024 * 1024];&#x2F;&#x2F;1MB（一次最多拷贝1MB）</span><br><span class="line">            int read &#x3D; 0;</span><br><span class="line">            while ((read &#x3D; fis.read(bytes)) !&#x3D; -1)&#123;</span><br><span class="line">                fos.write(bytes,0,read);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (fis !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fos !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">&#x2F;&#x2F;BufferedReader：带有缓冲区的流，使用这个流的时候，不需要自定义char数组，或者说不需要定义byte数组，自带缓冲</span><br><span class="line">public class BufferedReaderTest01 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        FileReader fr &#x3D; new FileReader(&quot;temp.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F;当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流</span><br><span class="line">        &#x2F;&#x2F;外部负责包装这个流，叫做：包装流，还有一个名字：处理流</span><br><span class="line">        &#x2F;&#x2F;像当前这个程序：FileReader就是一个节点流，BufferedReader就是包装流&#x2F;处理流</span><br><span class="line">        BufferedReader br &#x3D; new BufferedReader(fr);</span><br><span class="line">&#x2F;*        String firstLine &#x3D; br.readLine();</span><br><span class="line">        System.out.println(firstLine);&#x2F;&#x2F;abcde</span><br><span class="line">        String secondLine &#x3D; br.readLine();</span><br><span class="line">        System.out.println(secondLine);&#x2F;&#x2F;263</span><br><span class="line">        String thirdLine &#x3D; br.readLine();</span><br><span class="line">        System.out.println(thirdLine);&#x2F;&#x2F;26*&#x2F;</span><br><span class="line">        String s &#x3D; null;</span><br><span class="line">        while ((s &#x3D; br.readLine()) !&#x3D; null)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            &#x2F;*abcde</span><br><span class="line">            263</span><br><span class="line">            26*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭（源代码）</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流（InputStreamReader）"><a href="#转换流（InputStreamReader）" class="headerlink" title="转换流（InputStreamReader）"></a>转换流（InputStreamReader）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">public class BufferedReaderTest02 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">&#x2F;*        &#x2F;&#x2F;字节流</span><br><span class="line">        FileInputStream in &#x3D; new FileInputStream(&quot;temp.txt&quot;);</span><br><span class="line">        &#x2F;&#x2F;转换流转换</span><br><span class="line">        InputStreamReader read &#x3D; new InputStreamReader(in);</span><br><span class="line">        &#x2F;&#x2F;这个构造方法只能传一个字符流，不能传字节流</span><br><span class="line">        BufferedReader br &#x3D; new BufferedReader(read);*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;合并</span><br><span class="line">        BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;temp.txt&quot;)));</span><br><span class="line">        String s &#x3D; null;</span><br><span class="line">        while ((s &#x3D; br.readLine()) !&#x3D; null)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            &#x2F;*abcde</span><br><span class="line">            263</span><br><span class="line">            26*&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DataInputStream和DataOutputStream"><a href="#DataInputStream和DataOutputStream" class="headerlink" title="DataInputStream和DataOutputStream"></a>DataInputStream和DataOutputStream</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">public class DataOutputStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F;创建数据专属的字节输出流</span><br><span class="line">        DataOutputStream dos &#x3D; new DataOutputStream(new FileOutputStream(&quot;data&quot;));</span><br><span class="line">        &#x2F;&#x2F;写数据</span><br><span class="line">        byte b &#x3D; 100;</span><br><span class="line">        short s &#x3D; 200;</span><br><span class="line">        int i &#x3D; 300;</span><br><span class="line">        long l &#x3D; 400L;</span><br><span class="line">        float f &#x3D; 3.0f;</span><br><span class="line">        double d &#x3D; 3.14;</span><br><span class="line">        boolean sex &#x3D; false;</span><br><span class="line">        char c &#x3D; &#39;a&#39;;</span><br><span class="line">        &#x2F;&#x2F;写,把数据以及数据的类型一并写到文件当中</span><br><span class="line">        dos.writeByte(b);</span><br><span class="line">        dos.writeShort(s);</span><br><span class="line">        dos.writeInt(i);</span><br><span class="line">        dos.writeLong(l);</span><br><span class="line">        dos.writeFloat(f);</span><br><span class="line">        dos.writeDouble(d);</span><br><span class="line">        dos.writeBoolean(sex);</span><br><span class="line">        dos.writeChar(c);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">&#x2F;&#x2F;DataInputStreamTest：数据字节输入流</span><br><span class="line">&#x2F;&#x2F;DataOutputStreamTest写的文件，只能DataInputStreamTest去读</span><br><span class="line">&#x2F;&#x2F;并且读的时候，你需要提前知道写入的顺序，读的顺序需要和写的顺序一致，才可以正常取出数据</span><br><span class="line">public class DataInputStreamTest01 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        DataInputStream dis &#x3D; new DataInputStream(new FileInputStream(&quot;data&quot;));</span><br><span class="line">        &#x2F;&#x2F;开始读</span><br><span class="line">        byte b &#x3D; dis.readByte();</span><br><span class="line">        short s &#x3D; dis.readShort();</span><br><span class="line">        int i &#x3D; dis.readInt();</span><br><span class="line">        long l &#x3D; dis.readLong();</span><br><span class="line">        float f &#x3D; dis.readFloat();</span><br><span class="line">        double d &#x3D; dis.readDouble();</span><br><span class="line">        boolean sex &#x3D; dis.readBoolean();</span><br><span class="line">        char c &#x3D; dis.readChar();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i+1000);</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(sex);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">&#x2F;*</span><br><span class="line">        100</span><br><span class="line">        200</span><br><span class="line">        300</span><br><span class="line">        1300</span><br><span class="line">        400</span><br><span class="line">        3.0</span><br><span class="line">        3.14</span><br><span class="line">        false</span><br><span class="line">        a</span><br><span class="line">*&#x2F;</span><br><span class="line">        dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">&#x2F;&#x2F;PrintStream：标准的字节输出流，默认输出到控制台</span><br><span class="line">public class PrintStreamTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#x2F;&#x2F;可以改变标准输出流的输出方向嘛？可以</span><br><span class="line">        &#x2F;*&#x2F;&#x2F;这些是之前System类使用过的方法和属性</span><br><span class="line">        System.gc();</span><br><span class="line">        System.currentTimeMillis();</span><br><span class="line">        PrintStream ps2 &#x3D; System.out;</span><br><span class="line">        System.exit(0);</span><br><span class="line">        System.arraycopy(...)*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;标准输出流不再指向控制台，指向“log”文件</span><br><span class="line">        PrintStream log &#x3D; new PrintStream(new FileOutputStream(&quot;log&quot;));</span><br><span class="line">        &#x2F;&#x2F;修改输出方向，将输出方向修改到“log”文件</span><br><span class="line">        System.setOut(log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>Logger类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PrintStream pr &#x3D; new PrintStream(new FileOutputStream(&quot;log.txt&quot;,true));</span><br><span class="line">            &#x2F;&#x2F;改变输出方向</span><br><span class="line">            System.setOut(pr);</span><br><span class="line">            &#x2F;&#x2F;日期当前时间</span><br><span class="line">            Date newTime &#x3D; new Date();</span><br><span class="line">            SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);</span><br><span class="line">            String str &#x3D; sdf.format(newTime);</span><br><span class="line">            System.out.println(str+&quot;:&quot;+msg);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogTest类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">public class LogTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试工具是否好用</span><br><span class="line">        Logger.log(&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;);</span><br><span class="line">        Logger.log(&quot;调用了UserService的doSome()方法&quot;);</span><br><span class="line">        Logger.log(&quot;用户尝试进行登录，验证失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是新建一个log.txt文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-01-15 00:01:12 701:调用了System类的gc()方法，建议启动垃圾回收</span><br><span class="line">2020-01-15 00:01:12 746:调用了UserService的doSome()方法</span><br><span class="line">2020-01-15 00:01:12 746:用户尝试进行登录，验证失败</span><br><span class="line">2020-01-15 00:01:24 655:调用了System类的gc()方法，建议启动垃圾回收</span><br><span class="line">2020-01-15 00:01:24 707:调用了UserService的doSome()方法</span><br><span class="line">2020-01-15 00:01:24 708:用户尝试进行登录，验证失败</span><br></pre></td></tr></table></figure>

<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class FileTest01 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        File f1 &#x3D; new File(&quot;G:&#x2F;file&quot;);</span><br><span class="line">        &#x2F;&#x2F;判断是否存在</span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line">        &#x2F;&#x2F;如果G:&#x2F;file不存在，则以文件的形式创造出来</span><br><span class="line">        &#x2F;*if (!f1.exists())&#123;</span><br><span class="line">            f1.createNewFile();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;如果G:&#x2F;file不存在，则以目录的形式创造出来</span><br><span class="line">        &#x2F;*if (!f1.exists())&#123;</span><br><span class="line">            f1.mkdir();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;可以创建多重目录</span><br><span class="line">      &#x2F;*  File f2 &#x3D; new File(&quot;G:&#x2F;a&#x2F;b&#x2F;c&#x2F;d&quot;);</span><br><span class="line">        if (!f2.exists())&#123;</span><br><span class="line">            f2.mkdirs();</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        File f3 &#x3D; new File(&quot;G:\\JavaTest\\javaTest\\src\\com\\java\\ioTest\\FileTest01.java&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取文件的父路径</span><br><span class="line">        String parentPath &#x3D; f3.getParent();</span><br><span class="line">        System.out.println(parentPath);&#x2F;&#x2F;G:\JavaTest\javaTest\src\com\java\ioTest</span><br><span class="line">        File parentFile &#x3D; f3.getParentFile();</span><br><span class="line">        System.out.println(&quot;获取绝对路径&quot;+parentFile.getAbsolutePath());&#x2F;&#x2F;获取绝对路径G:\JavaTest\javaTest\src\com\java\ioTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取当前目录下的所有子文件"><a href="#获取当前目录下的所有子文件" class="headerlink" title="获取当前目录下的所有子文件"></a>获取当前目录下的所有子文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.ioTest;</span><br><span class="line">import java.io.File;</span><br><span class="line">public class FileTest03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f &#x3D; new File(&quot;C:\\Users\\lyl93\\Desktop\\blog\\source\\_posts&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取当前目录下的所有子文件</span><br><span class="line">        File[] files &#x3D; f.listFiles();</span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
</search>
